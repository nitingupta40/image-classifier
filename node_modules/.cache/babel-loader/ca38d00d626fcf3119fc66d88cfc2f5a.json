{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { convertToTensor } from '../tensor_util_env';\nimport * as util from '../util';\nimport { batchToSpaceND } from './batch_to_space_nd';\nimport * as conv_util from './conv_util';\nimport { op } from './operation';\nimport { spaceToBatchND } from './space_to_batch_nd';\n/**\n * Computes the 2D max pooling of an image.\n *\n * @param x The input tensor, of rank 4 or rank 3 of shape\n *     `[batch, height, width, inChannels]`. If rank 3, batch of 1 is assumed.\n * @param filterSize The filter size: `[filterHeight, filterWidth]`. If\n *     `filterSize` is a single number, then `filterHeight == filterWidth`.\n * @param strides The strides of the pooling: `[strideHeight, strideWidth]`. If\n *     `strides` is a single number, then `strideHeight == strideWidth`.\n * @param dilations The dilation rates: `[dilationHeight, dilationWidth]`\n *     in which we sample input values across the height and width dimensions\n *     in dilated pooling. Defaults to `[1, 1]`. If `dilations` is a single\n *     number, then `dilationHeight == dilationWidth`. If it is greater than\n *     1, then all values of `strides` must be 1.\n * @param pad The type of padding algorithm.\n *    - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *    - `valid`: output will be smaller than input if filter is larger\n *       than 1x1.\n *    - For more info, see this guide:\n *     [https://www.tensorflow.org/api_guides/python/nn#Convolution](\n *          https://www.tensorflow.org/api_guides/python/nn#Convolution)\n * @param dimRoundingMode The rounding mode used when computing output\n *     dimensions if pad is a number. If none is provided, it will not round\n *     and error if the output is of fractional size.\n */\n\nfunction maxPoolImpl_(x, filterSize, strides, dilations, pad, dimRoundingMode) {\n  const $x = convertToTensor(x, 'x', 'maxPool');\n  let x4D = $x;\n  let reshapedTo4D = false;\n\n  if ($x.rank === 3) {\n    reshapedTo4D = true;\n    x4D = $x.as4D(1, $x.shape[0], $x.shape[1], $x.shape[2]);\n  }\n\n  if (dilations == null) {\n    dilations = [1, 1];\n  }\n\n  util.assert(x4D.rank === 4, () => `Error in maxPool: input must be rank 4 but got rank ${x4D.rank}.`);\n  util.assert(conv_util.eitherStridesOrDilationsAreOne(strides, dilations), () => 'Error in maxPool: Either strides or dilations must be 1. ' + `Got strides ${strides} and dilations '${dilations}'`);\n\n  if (dimRoundingMode != null) {\n    util.assert(util.isInt(pad), () => `Error in maxPool: pad must be an integer when using, ` + `dimRoundingMode ${dimRoundingMode} but got pad ${pad}.`);\n  }\n\n  const convInfo = conv_util.computePool2DInfo(x4D.shape, filterSize, strides, dilations, pad, dimRoundingMode);\n\n  if (convInfo.filterWidth === 1 && convInfo.filterHeight === 1 && util.arraysEqual(convInfo.inShape, convInfo.outShape)) {\n    return $x.clone();\n  }\n\n  const grad = (dy, saved) => {\n    const [x4D, y] = saved;\n    return {\n      x: () => maxPoolBackprop(dy, x4D, y, filterSize, strides, dilations, pad)\n    };\n  };\n\n  const inputsToSave = [x4D];\n  const res = ENGINE.runKernelFunc((backend, save) => {\n    const y = backend.maxPool(x4D, convInfo);\n    save([x4D, y]);\n    return y;\n  }, {\n    x: x4D\n  }, grad, 'MaxPool', convInfo, inputsToSave);\n\n  if (reshapedTo4D) {\n    return res.as3D(res.shape[1], res.shape[2], res.shape[3]);\n  }\n\n  return res;\n}\n/**\n * Computes the 2D max pooling of an image.\n *\n * @param x The input tensor, of rank 4 or rank 3 of shape\n *     `[batch, height, width, inChannels]`. If rank 3, batch of 1 is assumed.\n * @param filterSize The filter size: `[filterHeight, filterWidth]`. If\n *     `filterSize` is a single number, then `filterHeight == filterWidth`.\n * @param strides The strides of the pooling: `[strideHeight, strideWidth]`. If\n *     `strides` is a single number, then `strideHeight == strideWidth`.\n * @param pad The type of padding algorithm.\n *    - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *    - `valid`: output will be smaller than input if filter is larger\n *       than 1x1.\n *    - For more info, see this guide:\n *     [https://www.tensorflow.org/api_guides/python/nn#Convolution](\n *          https://www.tensorflow.org/api_guides/python/nn#Convolution)\n * @param dimRoundingMode The rounding mode used when computing output\n *     dimensions if pad is a number. If none is provided, it will not round\n *     and error if the output is of fractional size.\n */\n\n/** @doc {heading: 'Operations', subheading: 'Convolution'} */\n\n\nfunction maxPool_(x, filterSize, strides, pad, dimRoundingMode) {\n  return maxPoolImpl_(x, filterSize, strides, 1, pad, dimRoundingMode);\n}\n/**\n * Computes the 2D average pooling of an image.\n *\n * @param x The input tensor, of rank 4 or rank 3 of shape\n *     `[batch, height, width, inChannels]`. If rank 3, batch of 1 is assumed.\n * @param filterSize The filter size: `[filterHeight, filterWidth]`. If\n *     `filterSize` is a single number, then `filterHeight == filterWidth`.\n * @param strides The strides of the pooling: `[strideHeight, strideWidth]`. If\n *     `strides` is a single number, then `strideHeight == strideWidth`.\n * @param dilations The dilation rates: `[dilationHeight, dilationWidth]`\n *     in which we sample input values across the height and width dimensions\n *     in dilated pooling. Defaults to `[1, 1]`. If `dilations` is a single\n *     number, then `dilationHeight == dilationWidth`. If it is greater than\n *     1, then all values of `strides` must be 1.\n * @param pad The type of padding algorithm:\n *    - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *    - `valid`: output will be smaller than input if filter is larger\n *       than 1x1.\n *    - For more info, see this guide:\n *     [https://www.tensorflow.org/api_guides/python/nn#Convolution](\n *         https://www.tensorflow.org/api_guides/python/nn#Convolution)\n * @param dimRoundingMode The rounding mode used when computing output\n *     dimensions if pad is a number. If none is provided, it will not round\n *     and error if the output is of fractional size.\n */\n\n\nfunction avgPoolImpl_(x, filterSize, strides, dilations, pad, dimRoundingMode) {\n  const $x = convertToTensor(x, 'x', 'avgPool', 'float32');\n\n  if (dilations == null) {\n    dilations = [1, 1];\n  }\n\n  util.assert(conv_util.eitherStridesOrDilationsAreOne(strides, dilations), () => 'Error in avgPool: Either strides or dilations must be 1. ' + `Got strides ${strides} and dilations '${dilations}'`);\n  let x4D = $x;\n  let reshapedTo4D = false;\n\n  if ($x.rank === 3) {\n    reshapedTo4D = true;\n    x4D = $x.as4D(1, $x.shape[0], $x.shape[1], $x.shape[2]);\n  }\n\n  util.assert(x4D.rank === 4, () => `Error in avgPool: x must be rank 4 but got rank ${x4D.rank}.`);\n\n  if (dimRoundingMode != null) {\n    util.assert(util.isInt(pad), () => `Error in avgPool: pad must be an integer when using, ` + `dimRoundingMode ${dimRoundingMode} but got pad ${pad}.`);\n  }\n\n  const convInfo = conv_util.computePool2DInfo(x4D.shape, filterSize, strides, dilations, pad, dimRoundingMode);\n\n  if (convInfo.filterWidth === 1 && convInfo.filterHeight === 1 && util.arraysEqual(convInfo.inShape, convInfo.outShape)) {\n    return $x.clone();\n  }\n\n  const grad = dy => {\n    return {\n      x: () => avgPoolBackprop(dy, x4D, filterSize, strides, dilations, pad)\n    };\n  };\n\n  let res = ENGINE.runKernelFunc(backend => backend.avgPool(x4D, convInfo), {\n    x: x4D\n  }, grad, 'AvgPool', convInfo);\n  res = res.cast($x.dtype);\n\n  if (reshapedTo4D) {\n    return res.as3D(res.shape[1], res.shape[2], res.shape[3]);\n  }\n\n  return res;\n}\n/**\n * Computes the 2D average pooling of an image.\n *\n * @param x The input tensor, of rank 4 or rank 3 of shape\n *     `[batch, height, width, inChannels]`. If rank 3, batch of 1 is assumed.\n * @param filterSize The filter size: `[filterHeight, filterWidth]`. If\n *     `filterSize` is a single number, then `filterHeight == filterWidth`.\n * @param strides The strides of the pooling: `[strideHeight, strideWidth]`. If\n *     `strides` is a single number, then `strideHeight == strideWidth`.\n * @param pad The type of padding algorithm:\n *    - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *    - `valid`: output will be smaller than input if filter is larger\n *       than 1x1.\n *    - For more info, see this guide:\n *     [https://www.tensorflow.org/api_guides/python/nn#Convolution](\n *         https://www.tensorflow.org/api_guides/python/nn#Convolution)\n * @param dimRoundingMode The rounding mode used when computing output\n *     dimensions if pad is a number. If none is provided, it will not round\n *     and error if the output is of fractional size.\n */\n\n/** @doc {heading: 'Operations', subheading: 'Convolution'} */\n\n\nfunction avgPool_(x, filterSize, strides, pad, dimRoundingMode) {\n  return avgPoolImpl_(x, filterSize, strides, 1, pad, dimRoundingMode);\n}\n/**\n * Performs an N-D pooling operation\n *\n * @param input The input tensor, of rank 4 or rank 3 of shape\n *     `[batch, height, width, inChannels]`. If rank 3, batch of 1 is assumed.\n * @param windowShape The filter size: `[filterHeight, filterWidth]`. If\n *     `filterSize` is a single number, then `filterHeight == filterWidth`.\n * @param poolingType The type of pooling, either 'max' or 'avg'.\n * @param pad The type of padding algorithm:\n *    - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *    - `valid`: output will be smaller than input if filter is larger\n *       than 1x1.\n *    - For more info, see this guide:\n *     [https://www.tensorflow.org/api_guides/python/nn#Convolution](\n *         https://www.tensorflow.org/api_guides/python/nn#Convolution)\n * @param dilations The dilation rates: `[dilationHeight, dilationWidth]`\n *     in which we sample input values across the height and width dimensions\n *     in dilated pooling. Defaults to `[1, 1]`. If `dilationRate` is a single\n *     number, then `dilationHeight == dilationWidth`. If it is greater than\n *     1, then all values of `strides` must be 1.\n * @param strides The strides of the pooling: `[strideHeight, strideWidth]`. If\n *     `strides` is a single number, then `strideHeight == strideWidth`.\n */\n\n/** @doc {heading: 'Operations', subheading: 'Convolution'} */\n\n\nfunction pool_(input, windowShape, poolingType, pad, dilations, strides) {\n  if (dilations == null) {\n    dilations = [1, 1];\n  }\n\n  if (strides == null) {\n    strides = 1;\n  }\n\n  if (pad === 0) {\n    pad = 'valid';\n  }\n\n  const $x = convertToTensor(input, 'x', 'maxPool');\n  let x4D = $x;\n  let reshapedTo4D = false;\n\n  if ($x.rank === 3) {\n    reshapedTo4D = true;\n    x4D = $x.as4D(1, $x.shape[0], $x.shape[1], $x.shape[2]);\n  }\n\n  util.assert(conv_util.eitherStridesOrDilationsAreOne(strides, dilations), () => 'Error in pool: Either strides or dilations must be 1. ' + `Got strides ${strides} and dilations '${dilations}'`);\n  const convInfo = conv_util.computePool2DInfo(x4D.shape, windowShape, strides, dilations, pad);\n  const dilation = [convInfo.dilationHeight, convInfo.dilationWidth]; // The following implementation does batchToSpace(pool(spaceToBatch(x)))\n  // whenever dilation > 1 since the TF kernels do not support dilation > 1.\n  // tslint:disable-next-line:max-line-length\n  // https://github.com/tensorflow/tensorflow/blob/50f6bb67dc98c9b74630b6047aae7a4f8a40fd02/tensorflow/python/ops/nn_ops.py#L1037\n\n  let basePadding;\n\n  if (pad === 'same') {\n    basePadding = withSpaceToBatchBasePaddings([convInfo.filterHeight, convInfo.filterWidth], dilation);\n  } else {\n    basePadding = [[0, 0], [0, 0]];\n  }\n\n  const isDilationOne = dilation[0] === 1 && dilation[1] === 1;\n  const [adjustedPadding, adjustedCrops] = requiredSpaceToBatchPaddings([convInfo.inHeight, convInfo.inWidth], dilation, basePadding);\n  const convertedPad = isDilationOne ? pad : 'valid';\n  const convertedX = isDilationOne ? x4D : spaceToBatchND(x4D, dilation, adjustedPadding);\n  const forwardOp = poolingType === 'avg' ? () => avgPoolImpl_(convertedX, windowShape, strides, 1\n  /* dilation */\n  , convertedPad) : () => maxPoolImpl_(convertedX, windowShape, strides, 1\n  /* dilation */\n  , convertedPad);\n  const y = forwardOp();\n  const res = isDilationOne ? y : batchToSpaceND(y, dilation, adjustedCrops);\n\n  if (reshapedTo4D) {\n    return res.as3D(res.shape[1], res.shape[2], res.shape[3]);\n  }\n\n  return res;\n}\n/**\n * Computes the backprop of a 2D max pool.\n *\n * @param dy The dy error, of rank 4 or rank 3 of shape\n *     [batchSize, height, width, channels]. If rank 3, batch of 1 is\n * assumed.\n * @param input The original input image, of rank 4, of shape\n *     [batchSize, height, width, channels].\n * @param output The original output image, of rank 4, of shape\n *     [batchSize, outHeight, outWidth, channels].\n * @param filterSize The filter size: `[filterHeight, filterWidth]`. If\n *     `filterSize` is a single number, then `filterHeight == filterWidth`.\n * @param strides The strides of the pooling: `[strideHeight, strideWidth]`. If\n *     `strides` is a single number, then `strideHeight == strideWidth`.\n * @param pad A string from: 'same', 'valid'. The type of padding algorithm\n *     used in the forward prop of the op.\n * @param dimRoundingMode A string from: 'ceil', 'round', 'floor'. The\n *     rounding mode used when computing output dimensions if pad is a\n *     number. If none is provided, it will not round and error if the output\n *     is of fractional size.\n */\n\n\nfunction maxPoolBackprop(dy, input, output, filterSize, strides, dilations, pad, dimRoundingMode) {\n  const $dy = convertToTensor(dy, 'dy', 'maxPoolBackprop');\n  const $input = convertToTensor(input, 'input', 'maxPoolBackprop');\n  const $output = convertToTensor(output, 'output', 'maxPoolBackprop');\n  util.assert($input.rank === $dy.rank, () => `Rank of input (${$input.rank}) does not match rank of dy ` + `(${$dy.rank})`);\n\n  if (dilations == null) {\n    dilations = [1, 1];\n  }\n\n  util.assert(conv_util.eitherStridesOrDilationsAreOne(strides, dilations), () => 'Error in maxPoolBackProp: Either strides or dilations must be 1. ' + `Got strides ${strides} and dilations '${dilations}'`);\n  util.assert($dy.rank === 4, () => `Error in maxPoolBackprop: dy must be rank 4 but got rank ` + `${$dy.rank}.`);\n  util.assert($input.rank === 4, () => `Error in maxPoolBackprop: input must be rank 4 but got rank ` + `${$input.rank}.`);\n\n  if (dimRoundingMode != null) {\n    util.assert(util.isInt(pad), () => `Error in maxPoolBackprop: pad must be an integer when using, ` + `dimRoundingMode ${dimRoundingMode} but got pad ${pad}.`);\n  }\n\n  const convInfo = conv_util.computePool2DInfo($input.shape, filterSize, strides, dilations, pad, dimRoundingMode);\n  const res = ENGINE.runKernelFunc(backend => backend.maxPoolBackprop($dy, $input, $output, convInfo), {\n    $dy,\n    $input\n  });\n  return res;\n}\n/**\n * Computes the backprop of an 2D avg pool.\n *\n * @param dy The dy error, of rank 4 or rank 3 of shape\n *     [batchSize, height, width, channels]. If rank 3, batch of 1 is\n * assumed.\n * @param input The input image, of rank 4 or rank 3 of shape\n *     [batchSize, height, width, channels]. If rank 3, batch of 1 is\n * assumed.\n * @param filterSize The filter size: `[filterHeight, filterWidth]`. If\n *     `filterSize` is a single number, then `filterHeight == filterWidth`.\n * @param strides The strides of the pooling: `[strideHeight, strideWidth]`. If\n *     `strides` is a single number, then `strideHeight == strideWidth`.\n * @param pad A string from: 'same', 'valid'. The type of padding algorithm\n *     used in the forward prop of the op.\n */\n\n\nfunction avgPoolBackprop(dy, input, filterSize, strides, dilations, pad) {\n  const $dy = convertToTensor(dy, 'dy', 'avgPoolBackprop');\n  const $input = convertToTensor(input, 'input', 'avgPoolBackprop');\n  util.assert($input.rank === $dy.rank, () => `Rank of input (${$input.rank}) does not match rank of dy (${$dy.rank})`);\n\n  if (dilations == null) {\n    dilations = [1, 1];\n  }\n\n  util.assert(conv_util.eitherStridesOrDilationsAreOne(strides, dilations), () => 'Error in avgPoolBackprop: Either strides or dilations must be 1. ' + `Got strides ${strides} and dilations '${dilations}'`);\n  let input4D = $input;\n  let dy4D = $dy;\n  let reshapedTo4D = false;\n\n  if ($input.rank === 3) {\n    reshapedTo4D = true;\n    input4D = $input.as4D(1, $input.shape[0], $input.shape[1], $input.shape[2]);\n    dy4D = $dy.as4D(1, $dy.shape[0], $dy.shape[1], $dy.shape[2]);\n  }\n\n  util.assert(dy4D.rank === 4, () => `Error in avgPoolBackprop: dy must be rank 4 but got rank ` + `${dy4D.rank}.`);\n  util.assert(input4D.rank === 4, () => `Error in avgPoolBackprop: input must be rank 4 but got rank ` + `${input4D.rank}.`);\n  const convInfo = conv_util.computePool2DInfo(input4D.shape, filterSize, strides, dilations, pad);\n  const res = ENGINE.runKernelFunc(backend => backend.avgPoolBackprop(dy4D, input4D, convInfo), {\n    dy4D,\n    input4D\n  });\n\n  if (reshapedTo4D) {\n    return res.as3D(res.shape[1], res.shape[2], res.shape[3]);\n  }\n\n  return res;\n} // Helper function to compute crops and paddings for pool with dilation > 1.\n// tslint:disable-next-line:max-line-length\n// https://github.com/tensorflow/tensorflow/blob/50f6bb67dc98c9b74630b6047aae7a4f8a40fd02/tensorflow/python/ops/array_ops.py#L2184\n\n\nfunction requiredSpaceToBatchPaddings(inputShape, blockShape, basePadding) {\n  const padStart = basePadding.map(b => b[0]);\n  const origPadEnd = basePadding.map(b => b[1]);\n  const fullInputShape = inputShape.concat(padStart, origPadEnd);\n  const padEndExtra = blockShape.map((b, i) => (b - fullInputShape[i] % b) % b);\n  const padEnd = origPadEnd.map((s, i) => s + padEndExtra[i]);\n  const paddings = blockShape.map((_, i) => [padStart[i], padEnd[i]]);\n  const crops = blockShape.map((_, i) => [0, padEndExtra[i]]);\n  return [paddings, crops];\n} // Helper function to compute base paddings for pool with dilation > 1.\n// tslint:disable-next-line:max-line-length\n// https://github.com/tensorflow/tensorflow/blob/50f6bb67dc98c9b74630b6047aae7a4f8a40fd02/tensorflow/python/ops/nn_ops.py#L524\n\n\nfunction withSpaceToBatchBasePaddings(filterShape, dilation) {\n  // Spatial dimensions of the filters and the upsampled filters in which we\n  // introduce (rate - 1) zeros between consecutive filter values.\n  const dilatedFilterShape = filterShape.map((s, i) => {\n    return s + (s - 1) * (dilation[i] - 1);\n  });\n  const padExtraShape = dilatedFilterShape.map(s => s - 1); // When padding is odd, we pad more at end, following the same\n  // convention as conv2d.\n\n  const padExtraStart = padExtraShape.map(s => Math.floor(s / 2));\n  const padExtraEnd = padExtraShape.map((s, i) => s - padExtraStart[i]);\n  return padExtraShape.map((_, i) => {\n    return [padExtraStart[i], padExtraEnd[i]];\n  });\n}\n/**\n * Computes the 3D average pooling.\n *\n * ```js\n * const x = tf.tensor5d([1, 2, 3, 4, 5, 6, 7, 8], [1, 2, 2, 2, 1]);\n * const result = tf.avgPool3d(x, 2, 1, 'valid');\n * result.print();\n * ```\n *\n * @param x The input tensor, of rank 5 or rank 4 of shape\n *     `[batch, depth, height, width, inChannels]`.\n * @param filterSize The filter size:\n *     `[filterDepth, filterHeight, filterWidth]`.\n *     If `filterSize` is a single number,\n *     then `filterDepth == filterHeight == filterWidth`.\n * @param strides The strides of the pooling:\n *     `[strideDepth, strideHeight, strideWidth]`.\n *     If `strides` is a single number,\n *     then `strideDepth == strideHeight == strideWidth`.\n * @param pad The type of padding algorithm.\n *    - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *    - `valid`: output will be smaller than input if filter is larger\n *       than 1*1x1.\n *    - For more info, see this guide:\n *     [https://www.tensorflow.org/api_guides/python/nn#Convolution](\n *          https://www.tensorflow.org/api_guides/python/nn#Convolution)\n * @param dimRoundingMode The rounding mode used when computing output\n *     dimensions if pad is a number. If none is provided, it will not round\n *     and error if the output is of fractional size.\n * @param dataFormat An optional string from: \"NDHWC\", \"NCDHW\". Defaults to\n *     \"NDHWC\". Specify the data format of the input and output data. With the\n *     default format \"NDHWC\", the data is stored in the order of: [batch,\n *     depth, height, width, channels]. Only \"NDHWC\" is currently supported.\n * @param dilations The dilation rates:\n *     `[dilationDepth, dilationHeight, dilationWidth]`\n *     in which we sample input values across the depth, height and width\n *     dimensions in dilated pooling.\n *     Defaults to `[1, 1, 1]`. If `dilations` is a single number,\n *     then `dilationDepth == dilationHeight == dilationWidth`.\n *     If it is greater than 1, then all values of `strides` must be 1.\n */\n\n/** @doc {heading: 'Operations', subheading: 'Convolution'} */\n\n\nfunction avgPool3d_(x, filterSize, strides, pad, dimRoundingMode, dataFormat = 'NDHWC', dilations) {\n  const $x = convertToTensor(x, 'x', 'avgPool3d', 'float32');\n  let x5D = $x;\n  let reshapedTo5D = false;\n\n  if ($x.rank === 4) {\n    reshapedTo5D = true;\n    x5D = $x.as5D(1, $x.shape[0], $x.shape[1], $x.shape[2], $x.shape[3]);\n  }\n\n  if (dilations == null) {\n    dilations = [1, 1, 1];\n  }\n\n  util.assert(x5D.rank === 5, () => `Error in avgPool3d: x must be rank 5 but got rank ${x5D.rank}.`);\n  util.assert(dataFormat === 'NDHWC', () => `Error in avgPool3d: Only NDHWC is currently supported, ` + `but got dataFormat of ${dataFormat}`);\n  util.assert(conv_util.eitherStridesOrDilationsAreOne(strides, dilations), () => 'Error in avgPool3d: Either strides or dilations must be 1. ' + `Got strides ${strides} and dilations '${dilations}'`);\n\n  if (dimRoundingMode != null) {\n    util.assert(util.isInt(pad), () => `Error in avgPool3d: pad must be an integer when using, ` + `dimRoundingMode ${dimRoundingMode} but got pad ${pad}.`);\n  }\n\n  const convInfo = conv_util.computePool3DInfo(x5D.shape, filterSize, strides, dilations, pad, dimRoundingMode, dataFormat);\n\n  const grad = dy => {\n    return {\n      x: () => avgPool3dBackprop(dy, x5D, filterSize, strides, dilations, pad, dimRoundingMode)\n    };\n  };\n\n  let res = ENGINE.runKernelFunc(backend => backend.avgPool3d(x5D, convInfo), {\n    x: x5D\n  }, grad);\n  res = res.cast(x5D.dtype);\n\n  if (reshapedTo5D) {\n    return res.as4D(res.shape[1], res.shape[2], res.shape[3], res.shape[4]);\n  }\n\n  return res;\n}\n/**\n * Computes the backprop of a 3d avg pool.\n *\n * @param dy The dy error, of rank 5 of shape\n *     [batchSize, depth, height, width, channels].\n * assumed.\n * @param input The original input image, of rank 5 or rank4 of shape\n *     [batchSize, depth, height, width, channels].\n * @param filterSize The filter size:\n *     `[filterDepth, filterHeight, filterWidth]`.\n *     `filterSize` is a single number,\n *     then `filterDepth == filterHeight == filterWidth`.\n * @param strides The strides of the pooling:\n *     `[strideDepth, strideHeight, strideWidth]`. If\n *     `strides` is a single number, then `strideHeight == strideWidth`.\n * @param dilations The dilation rates:\n *     `[dilationDepth, dilationHeight, dilationWidth]`\n *     in which we sample input values across the depth, height and width\n *     dimensions in dilated pooling.\n *     Defaults to `[1, 1, 1]`. If `dilations` is a single number,\n *     then `dilationDepth == dilationHeight == dilationWidth`.\n *     If it is greater than 1, then all values of `strides` must be 1.\n * @param pad A string from: 'same', 'valid'. The type of padding algorithm\n *     used in the forward prop of the op.\n * @param dimRoundingMode A string from: 'ceil', 'round', 'floor'. The\n *     rounding mode used when computing output dimensions if pad is a\n *     number. If none is provided, it will not round and error if the output\n *     is of fractional size.\n */\n\n\nfunction avgPool3dBackprop(dy, input, filterSize, strides, dilations, pad, dimRoundingMode) {\n  const $dy = convertToTensor(dy, 'dy', 'avgPool3dBackprop');\n  const $input = convertToTensor(input, 'input', 'avgPool3dBackprop');\n  let dy5D = $dy;\n  let input5D = $input;\n  let reshapedTo5D = false;\n\n  if ($input.rank === 4) {\n    reshapedTo5D = true;\n    dy5D = $dy.as5D(1, $dy.shape[0], $dy.shape[1], $dy.shape[2], $dy.shape[3]);\n    input5D = $input.as5D(1, $input.shape[0], $input.shape[1], $input.shape[2], $input.shape[3]);\n  }\n\n  util.assert(dy5D.rank === 5, () => `Error in avgPool3dBackprop: dy must be rank 5 but got rank ` + `${dy5D.rank}.`);\n  util.assert(input5D.rank === 5, () => `Error in avgPool3dBackprop: input must be rank 5 but got rank ` + `${input5D.rank}.`);\n\n  if (dilations == null) {\n    dilations = [1, 1, 1];\n  }\n\n  util.assert(conv_util.eitherStridesOrDilationsAreOne(strides, dilations), () => 'Error in avgPool3dBackprop: Either strides or dilations ' + `must be 1. Got strides ${strides} and dilations '${dilations}'`);\n\n  if (dimRoundingMode != null) {\n    util.assert(util.isInt(pad), () => `Error in maxPool3dBackprop: pad must be an integer when ` + `using, dimRoundingMode ${dimRoundingMode} but got pad ${pad}.`);\n  }\n\n  const convInfo = conv_util.computePool3DInfo(input5D.shape, filterSize, strides, dilations, pad, dimRoundingMode);\n  const res = ENGINE.runKernelFunc(backend => backend.avgPool3dBackprop(dy5D, input5D, convInfo), {\n    dy5D,\n    input5D\n  });\n\n  if (reshapedTo5D) {\n    return res.as4D(res.shape[1], res.shape[2], res.shape[3], res.shape[4]);\n  }\n\n  return res;\n}\n/**\n * Computes the 3D max pooling.\n *\n * ```js\n * const x = tf.tensor5d([1, 2, 3, 4, 5, 6, 7, 8], [1, 2, 2, 2, 1]);\n * const result = tf.maxPool3d(x, 2, 1, 'valid');\n * result.print();\n * ```\n *\n * @param x The input tensor, of rank 5 or rank 4 of shape\n *     `[batch, depth, height, width, inChannels]`.\n * @param filterSize The filter size:\n *     `[filterDepth, filterHeight, filterWidth]`.\n *     If `filterSize` is a single number,\n *     then `filterDepth == filterHeight == filterWidth`.\n * @param strides The strides of the pooling:\n *     `[strideDepth, strideHeight, strideWidth]`.\n *     If `strides` is a single number,\n *     then `strideDepth == strideHeight == strideWidth`.\n * @param pad The type of padding algorithm.\n *    - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *    - `valid`: output will be smaller than input if filter is larger\n *       than 1*1x1.\n *    - For more info, see this guide:\n *     [https://www.tensorflow.org/api_guides/python/nn#Convolution](\n *          https://www.tensorflow.org/api_guides/python/nn#Convolution)\n * @param dimRoundingMode The rounding mode used when computing output\n *     dimensions if pad is a number. If none is provided, it will not round\n *     and error if the output is of fractional size.\n * @param dataFormat An optional string from: \"NDHWC\", \"NCDHW\". Defaults to\n *     \"NDHWC\". Specify the data format of the input and output data. With the\n *     default format \"NDHWC\", the data is stored in the order of: [batch,\n *     depth, height, width, channels]. Only \"NDHWC\" is currently supported.\n * @param dilations The dilation rates:\n *     `[dilationDepth, dilationHeight, dilationWidth]`\n *     in which we sample input values across the depth, height and width\n *     dimensions in dilated pooling.\n *     Defaults to `[1, 1, 1]`. If `dilations` is a single number,\n *     then `dilationDepth == dilationHeight == dilationWidth`.\n *     If it is greater than 1, then all values of `strides` must be 1.\n */\n\n/** @doc {heading: 'Operations', subheading: 'Convolution'} */\n\n\nfunction maxPool3d_(x, filterSize, strides, pad, dimRoundingMode, dataFormat = 'NDHWC', dilations) {\n  const $x = convertToTensor(x, 'x', 'maxPool3d');\n  let x5D = $x;\n  let reshapedTo5D = false;\n\n  if ($x.rank === 4) {\n    reshapedTo5D = true;\n    x5D = $x.as5D(1, $x.shape[0], $x.shape[1], $x.shape[2], $x.shape[3]);\n  }\n\n  if (dilations == null) {\n    dilations = [1, 1, 1];\n  }\n\n  util.assert(x5D.rank === 5, () => `Error in maxPool3d: x must be rank 5 but got rank ${x5D.rank}.`);\n  util.assert(dataFormat === 'NDHWC', () => `Error in maxPool3d: Only NDHWC is currently supported, ` + `but got dataFormat of ${dataFormat}`);\n  util.assert(conv_util.eitherStridesOrDilationsAreOne(strides, dilations), () => 'Error in maxPool3d: Either strides or dilations must be 1. ' + `Got strides ${strides} and dilations '${dilations}'`);\n\n  if (dimRoundingMode != null) {\n    util.assert(util.isInt(pad), () => `Error in maxPool3d: pad must be an integer when using, ` + `dimRoundingMode ${dimRoundingMode} but got pad ${pad}.`);\n  }\n\n  const convInfo = conv_util.computePool3DInfo(x5D.shape, filterSize, strides, dilations, pad, dimRoundingMode, dataFormat);\n\n  const grad = (dy, saved) => {\n    const [x5D, y] = saved;\n    return {\n      x: () => maxPool3dBackprop(dy, x5D, y, filterSize, strides, dilations, pad, dimRoundingMode)\n    };\n  };\n\n  const res = ENGINE.runKernelFunc((backend, save) => {\n    const y = backend.maxPool3d(x5D, convInfo);\n    save([x5D, y]);\n    return y;\n  }, {\n    x: x5D\n  }, grad);\n\n  if (reshapedTo5D) {\n    return res.as4D(res.shape[1], res.shape[2], res.shape[3], res.shape[4]);\n  }\n\n  return res;\n}\n/**\n * Computes the backprop of a 3d max pool.\n *\n * @param dy The dy error, of rank 5 of shape\n *     [batchSize, depth, height, width, channels].\n * assumed.\n * @param input The original input image, of rank 5 or rank 4 of shape\n *     [batchSize, depth, height, width, channels].\n * @param output The original output image, of rank 5 of shape\n *     [batchSize, outDepth, outHeight, outWidth, channels].\n * @param filterSize The filter size:\n *     `[filterDepth, filterHeight, filterWidth]`.\n *     `filterSize` is a single number,\n *     then `filterDepth == filterHeight == filterWidth`.\n * @param strides The strides of the pooling:\n *     `[strideDepth, strideHeight, strideWidth]`. If\n *     `strides` is a single number, then `strideHeight == strideWidth`.\n * @param dilations The dilation rates:\n *     `[dilationDepth, dilationHeight, dilationWidth]`\n *     in which we sample input values across the depth, height and width\n *     dimensions in dilated pooling.\n *     Defaults to `[1, 1, 1]`. If `dilations` is a single number,\n *     then `dilationDepth == dilationHeight == dilationWidth`.\n *     If it is greater than 1, then all values of `strides` must be 1.\n * @param pad A string from: 'same', 'valid'. The type of padding algorithm\n *     used in the forward prop of the op.\n * @param dimRoundingMode A string from: 'ceil', 'round', 'floor'. The\n *     rounding mode used when computing output dimensions if pad is a\n *     number. If none is provided, it will not round and error if the output\n *     is of fractional size.\n */\n\n\nfunction maxPool3dBackprop(dy, input, output, filterSize, strides, dilations, pad, dimRoundingMode) {\n  const $dy = convertToTensor(dy, 'dy', 'maxPool3dBackprop');\n  const $input = convertToTensor(input, 'input', 'maxPool3dBackprop');\n  const $output = convertToTensor(output, 'output', 'maxPool3dBackprop');\n  let dy5D = $dy;\n  let input5D = $input;\n  let output5D = $output;\n  let reshapedTo5D = false;\n\n  if ($input.rank === 4) {\n    reshapedTo5D = true;\n    dy5D = $dy.as5D(1, $dy.shape[0], $dy.shape[1], $dy.shape[2], $dy.shape[3]);\n    input5D = $input.as5D(1, $input.shape[0], $input.shape[1], $input.shape[2], $input.shape[3]);\n    output5D = $output.as5D(1, $output.shape[0], $output.shape[1], $output.shape[2], $output.shape[3]);\n  }\n\n  util.assert(dy5D.rank === 5, () => `Error in maxPool3dBackprop: dy must be rank 5 but got rank ` + `${dy5D.rank}.`);\n  util.assert(input5D.rank === 5, () => `Error in maxPool3dBackprop: input must be rank 5 but got rank ` + `${input5D.rank}.`);\n  util.assert(output5D.rank === 5, () => `Error in maxPool3dBackprop: output must be rank 5 but got rank ` + `${output5D.rank}.`);\n\n  if (dilations == null) {\n    dilations = [1, 1, 1];\n  }\n\n  util.assert(conv_util.eitherStridesOrDilationsAreOne(strides, dilations), () => 'Error in maxPool3dBackprop: Either strides or dilations ' + `must be 1. Got strides ${strides} and dilations '${dilations}'`);\n\n  if (dimRoundingMode != null) {\n    util.assert(util.isInt(pad), () => `Error in maxPool3dBackprop: pad must be an integer when ` + `using, dimRoundingMode ${dimRoundingMode} but got pad ${pad}.`);\n  }\n\n  const convInfo = conv_util.computePool3DInfo(input5D.shape, filterSize, strides, dilations, pad, dimRoundingMode);\n  const res = ENGINE.runKernelFunc(backend => backend.maxPool3dBackprop(dy5D, input5D, output5D, convInfo), {\n    dy5D,\n    input5D\n  });\n\n  if (reshapedTo5D) {\n    return res.as4D(res.shape[1], res.shape[2], res.shape[3], res.shape[4]);\n  }\n\n  return res;\n}\n/**\n * Computes the 2D max pooling of an image with Argmax index.\n * The indices in argmax are flattened, so that a maximum value at position `[b,\n * y, x, c]` becomes flattened index: `(y * width + x) * channels + c` if\n * include_batch_in_index is False; `((b * height + y) * width + x) * channels\n * +c` if include_batch_in_index is True.\n *\n * The indices returned are always in `[0, height) x [0, width)` before\n * flattening.\n *\n * @param x The input tensor, of rank 4 or rank 3 of shape\n *     `[batch, height, width, inChannels]`. If rank 3, batch of 1 is assumed.\n * @param filterSize The filter size: `[filterHeight, filterWidth]`. If\n *     `filterSize` is a single number, then `filterHeight == filterWidth`.\n * @param strides The strides of the pooling: `[strideHeight, strideWidth]`. If\n *     `strides` is a single number, then `strideHeight == strideWidth`.\n * @param dataFormat An optional string from: \"NDHWC\", \"NCDHW\". Defaults to\n *     \"NDHWC\". Specify the data format of the input and output data. With the\n *     default format \"NDHWC\", the data is stored in the order of: [batch,\n *     depth, height, width, channels]. Only \"NDHWC\" is currently supported.\n * @param pad The type of padding algorithm.\n *    - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *    - `valid`: output will be smaller than input if filter is larger\n *       than 1x1.\n *    - For more info, see this guide:\n *     [https://www.tensorflow.org/api_guides/python/nn#Convolution](\n *          https://www.tensorflow.org/api_guides/python/nn#Convolution)\n * @param includeBatchIndex Defaults to False. Whether to include batch\n *    dimension in flattened index of argmax.\n */\n\n/** @doc {heading: 'Operations', subheading: 'Convolution'} */\n\n/** @doc {heading: 'Operations', subheading: 'Convolution'} */\n\n\nfunction maxPoolWithArgmax_(x, filterSize, strides, pad, includeBatchInIndex = false) {\n  const $x = convertToTensor(x, 'x', 'maxPoolWithArgmax');\n  const attrs = {\n    filterSize,\n    strides,\n    pad,\n    includeBatchInIndex\n  };\n  const result = ENGINE.runKernel('MaxPoolWithArgmax', {\n    x: $x\n  }, attrs);\n  return {\n    result: result[0],\n    indexes: result[1]\n  };\n}\n\nexport const maxPool = op({\n  maxPool_\n});\nexport const avgPool = op({\n  avgPool_\n});\nexport const pool = op({\n  pool_\n});\nexport const maxPool3d = op({\n  maxPool3d_\n});\nexport const avgPool3d = op({\n  avgPool3d_\n});\nexport const maxPoolWithArgmax = op({\n  maxPoolWithArgmax_\n});","map":{"version":3,"sources":["../../src/ops/pool.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;AAiBA,SAAQ,MAAR,QAAqB,WAArB;AAGA,SAAQ,eAAR,QAA8B,oBAA9B;AAEA,OAAO,KAAK,IAAZ,MAAsB,SAAtB;AAEA,SAAQ,cAAR,QAA6B,qBAA7B;AACA,OAAO,KAAK,SAAZ,MAA2B,aAA3B;AACA,SAAQ,EAAR,QAAiB,aAAjB;AACA,SAAQ,cAAR,QAA6B,qBAA7B;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BA,SAAS,YAAT,CACI,CADJ,EACqB,UADrB,EAEI,OAFJ,EAEsC,SAFtC,EAGI,GAHJ,EAGgC,eAHhC,EAGwE;AACtE,QAAM,EAAE,GAAG,eAAe,CAAC,CAAD,EAAI,GAAJ,EAAS,SAAT,CAA1B;AAEA,MAAI,GAAG,GAAG,EAAV;AACA,MAAI,YAAY,GAAG,KAAnB;;AACA,MAAI,EAAE,CAAC,IAAH,KAAY,CAAhB,EAAmB;AACjB,IAAA,YAAY,GAAG,IAAf;AACA,IAAA,GAAG,GAAG,EAAE,CAAC,IAAH,CAAQ,CAAR,EAAW,EAAE,CAAC,KAAH,CAAS,CAAT,CAAX,EAAwB,EAAE,CAAC,KAAH,CAAS,CAAT,CAAxB,EAAqC,EAAE,CAAC,KAAH,CAAS,CAAT,CAArC,CAAN;AACD;;AACD,MAAI,SAAS,IAAI,IAAjB,EAAuB;AACrB,IAAA,SAAS,GAAG,CAAC,CAAD,EAAI,CAAJ,CAAZ;AACD;;AACD,EAAA,IAAI,CAAC,MAAL,CACI,GAAG,CAAC,IAAJ,KAAa,CADjB,EAEI,MAAM,uDAAuD,GAAG,CAAC,IAAI,GAFzE;AAGA,EAAA,IAAI,CAAC,MAAL,CACI,SAAS,CAAC,8BAAV,CAAyC,OAAzC,EAAkD,SAAlD,CADJ,EAEI,MAAM,8DACF,eAAe,OAAO,mBAAmB,SAAS,GAH1D;;AAIA,MAAI,eAAe,IAAI,IAAvB,EAA6B;AAC3B,IAAA,IAAI,CAAC,MAAL,CACI,IAAI,CAAC,KAAL,CAAW,GAAX,CADJ,EAEI,MAAM,uDAAA,GACF,mBAAmB,eAAe,gBAAgB,GAAG,GAH7D;AAID;;AACD,QAAM,QAAQ,GAAG,SAAS,CAAC,iBAAV,CACb,GAAG,CAAC,KADS,EACF,UADE,EACU,OADV,EACmB,SADnB,EAC8B,GAD9B,EACmC,eADnC,CAAjB;;AAEA,MAAI,QAAQ,CAAC,WAAT,KAAyB,CAAzB,IAA8B,QAAQ,CAAC,YAAT,KAA0B,CAAxD,IACA,IAAI,CAAC,WAAL,CAAiB,QAAQ,CAAC,OAA1B,EAAmC,QAAQ,CAAC,QAA5C,CADJ,EAC2D;AACzD,WAAO,EAAE,CAAC,KAAH,EAAP;AACD;;AAED,QAAM,IAAI,GAAG,CAAC,EAAD,EAAe,KAAf,KAAkC;AAC7C,UAAM,CAAC,GAAD,EAAM,CAAN,IAAW,KAAjB;AACA,WAAO;AACL,MAAA,CAAC,EAAE,MAAM,eAAe,CACpB,EADoB,EAChB,GADgB,EACC,CADD,EACgB,UADhB,EAC4B,OAD5B,EACqC,SADrC,EAEpB,GAFoB;AADnB,KAAP;AAKD,GAPD;;AASA,QAAM,YAAY,GAAG,CAAC,GAAD,CAArB;AACA,QAAM,GAAG,GAAG,MAAM,CAAC,aAAP,CAAqB,CAAC,OAAD,EAAU,IAAV,KAAkB;AACjD,UAAM,CAAC,GAAG,OAAO,CAAC,OAAR,CAAgB,GAAhB,EAAqB,QAArB,CAAV;AACA,IAAA,IAAI,CAAC,CAAC,GAAD,EAAM,CAAN,CAAD,CAAJ;AACA,WAAO,CAAP;AACD,GAJW,EAIT;AAAC,IAAA,CAAC,EAAE;AAAJ,GAJS,EAIC,IAJD,EAIO,SAJP,EAIkB,QAJlB,EAI4B,YAJ5B,CAAZ;;AAKA,MAAI,YAAJ,EAAkB;AAChB,WAAO,GAAG,CAAC,IAAJ,CAAS,GAAG,CAAC,KAAJ,CAAU,CAAV,CAAT,EAAuB,GAAG,CAAC,KAAJ,CAAU,CAAV,CAAvB,EAAqC,GAAG,CAAC,KAAJ,CAAU,CAAV,CAArC,CAAP;AACD;;AACD,SAAO,GAAP;AACD;AAED;;;;;;;;;;;;;;;;;;;;;;AAqBA;;;AACA,SAAS,QAAT,CACI,CADJ,EACqB,UADrB,EAEI,OAFJ,EAEsC,GAFtC,EAGI,eAHJ,EAG4C;AAC1C,SAAO,YAAY,CAAC,CAAD,EAAI,UAAJ,EAAgB,OAAhB,EAAyB,CAAzB,EAA4B,GAA5B,EAAiC,eAAjC,CAAnB;AACD;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BA,SAAS,YAAT,CACI,CADJ,EACqB,UADrB,EAEI,OAFJ,EAEsC,SAFtC,EAGI,GAHJ,EAGgC,eAHhC,EAGwE;AACtE,QAAM,EAAE,GAAG,eAAe,CAAC,CAAD,EAAI,GAAJ,EAAS,SAAT,EAAoB,SAApB,CAA1B;;AACA,MAAI,SAAS,IAAI,IAAjB,EAAuB;AACrB,IAAA,SAAS,GAAG,CAAC,CAAD,EAAI,CAAJ,CAAZ;AACD;;AACD,EAAA,IAAI,CAAC,MAAL,CACI,SAAS,CAAC,8BAAV,CAAyC,OAAzC,EAAkD,SAAlD,CADJ,EAEI,MAAM,8DACF,eAAe,OAAO,mBAAmB,SAAS,GAH1D;AAIA,MAAI,GAAG,GAAG,EAAV;AACA,MAAI,YAAY,GAAG,KAAnB;;AACA,MAAI,EAAE,CAAC,IAAH,KAAY,CAAhB,EAAmB;AACjB,IAAA,YAAY,GAAG,IAAf;AACA,IAAA,GAAG,GAAG,EAAE,CAAC,IAAH,CAAQ,CAAR,EAAW,EAAE,CAAC,KAAH,CAAS,CAAT,CAAX,EAAwB,EAAE,CAAC,KAAH,CAAS,CAAT,CAAxB,EAAqC,EAAE,CAAC,KAAH,CAAS,CAAT,CAArC,CAAN;AACD;;AACD,EAAA,IAAI,CAAC,MAAL,CACI,GAAG,CAAC,IAAJ,KAAa,CADjB,EAEI,MAAM,mDAAmD,GAAG,CAAC,IAAI,GAFrE;;AAGA,MAAI,eAAe,IAAI,IAAvB,EAA6B;AAC3B,IAAA,IAAI,CAAC,MAAL,CACI,IAAI,CAAC,KAAL,CAAW,GAAX,CADJ,EAEI,MAAM,uDAAA,GACF,mBAAmB,eAAe,gBAAgB,GAAG,GAH7D;AAID;;AAED,QAAM,QAAQ,GAAG,SAAS,CAAC,iBAAV,CACb,GAAG,CAAC,KADS,EACF,UADE,EACU,OADV,EACmB,SADnB,EAC8B,GAD9B,EACmC,eADnC,CAAjB;;AAEA,MAAI,QAAQ,CAAC,WAAT,KAAyB,CAAzB,IAA8B,QAAQ,CAAC,YAAT,KAA0B,CAAxD,IACA,IAAI,CAAC,WAAL,CAAiB,QAAQ,CAAC,OAA1B,EAAmC,QAAQ,CAAC,QAA5C,CADJ,EAC2D;AACzD,WAAO,EAAE,CAAC,KAAH,EAAP;AACD;;AAED,QAAM,IAAI,GAAI,EAAD,IAAiB;AAC5B,WAAO;AACL,MAAA,CAAC,EAAE,MAAM,eAAe,CAAC,EAAD,EAAK,GAAL,EAAU,UAAV,EAAsB,OAAtB,EAA+B,SAA/B,EAA0C,GAA1C;AADnB,KAAP;AAGD,GAJD;;AAMA,MAAI,GAAG,GAAG,MAAM,CAAC,aAAP,CACN,OAAO,IAAI,OAAO,CAAC,OAAR,CAAgB,GAAhB,EAAqB,QAArB,CADL,EACqC;AAAC,IAAA,CAAC,EAAE;AAAJ,GADrC,EAC+C,IAD/C,EACqD,SADrD,EAEN,QAFM,CAAV;AAGA,EAAA,GAAG,GAAG,GAAG,CAAC,IAAJ,CAAS,EAAE,CAAC,KAAZ,CAAN;;AACA,MAAI,YAAJ,EAAkB;AAChB,WAAO,GAAG,CAAC,IAAJ,CAAS,GAAG,CAAC,KAAJ,CAAU,CAAV,CAAT,EAAuB,GAAG,CAAC,KAAJ,CAAU,CAAV,CAAvB,EAAqC,GAAG,CAAC,KAAJ,CAAU,CAAV,CAArC,CAAP;AACD;;AACD,SAAO,GAAP;AACD;AAED;;;;;;;;;;;;;;;;;;;;;;AAqBA;;;AACA,SAAS,QAAT,CACI,CADJ,EACqB,UADrB,EAEI,OAFJ,EAEsC,GAFtC,EAGI,eAHJ,EAG4C;AAC1C,SAAO,YAAY,CAAC,CAAD,EAAI,UAAJ,EAAgB,OAAhB,EAAyB,CAAzB,EAA4B,GAA5B,EAAiC,eAAjC,CAAnB;AACD;AAED;;;;;;;;;;;;;;;;;;;;;;;;;AAwBA;;;AACA,SAAS,KAAT,CACI,KADJ,EACyB,WADzB,EAEI,WAFJ,EAE8B,GAF9B,EAGI,SAHJ,EAGyC,OAHzC,EAG0E;AACxE,MAAI,SAAS,IAAI,IAAjB,EAAuB;AACrB,IAAA,SAAS,GAAG,CAAC,CAAD,EAAI,CAAJ,CAAZ;AACD;;AACD,MAAI,OAAO,IAAI,IAAf,EAAqB;AACnB,IAAA,OAAO,GAAG,CAAV;AACD;;AACD,MAAI,GAAG,KAAK,CAAZ,EAAe;AACb,IAAA,GAAG,GAAG,OAAN;AACD;;AACD,QAAM,EAAE,GAAG,eAAe,CAAC,KAAD,EAAQ,GAAR,EAAa,SAAb,CAA1B;AACA,MAAI,GAAG,GAAG,EAAV;AACA,MAAI,YAAY,GAAG,KAAnB;;AACA,MAAI,EAAE,CAAC,IAAH,KAAY,CAAhB,EAAmB;AACjB,IAAA,YAAY,GAAG,IAAf;AACA,IAAA,GAAG,GAAG,EAAE,CAAC,IAAH,CAAQ,CAAR,EAAW,EAAE,CAAC,KAAH,CAAS,CAAT,CAAX,EAAwB,EAAE,CAAC,KAAH,CAAS,CAAT,CAAxB,EAAqC,EAAE,CAAC,KAAH,CAAS,CAAT,CAArC,CAAN;AACD;;AACD,EAAA,IAAI,CAAC,MAAL,CACI,SAAS,CAAC,8BAAV,CAAyC,OAAzC,EAAkD,SAAlD,CADJ,EAEI,MAAM,2DACF,eAAe,OAAO,mBAAmB,SAAS,GAH1D;AAIA,QAAM,QAAQ,GAAG,SAAS,CAAC,iBAAV,CACb,GAAG,CAAC,KADS,EACF,WADE,EACW,OADX,EACoB,SADpB,EAC+B,GAD/B,CAAjB;AAEA,QAAM,QAAQ,GACV,CAAC,QAAQ,CAAC,cAAV,EAA0B,QAAQ,CAAC,aAAnC,CADJ,CAvBwE,CA0BxE;AACA;AACA;AACA;;AAEA,MAAI,WAAJ;;AACA,MAAI,GAAG,KAAK,MAAZ,EAAoB;AAClB,IAAA,WAAW,GAAG,4BAA4B,CACtC,CAAC,QAAQ,CAAC,YAAV,EAAwB,QAAQ,CAAC,WAAjC,CADsC,EACS,QADT,CAA1C;AAED,GAHD,MAGO;AACL,IAAA,WAAW,GAAG,CAAC,CAAC,CAAD,EAAI,CAAJ,CAAD,EAAS,CAAC,CAAD,EAAI,CAAJ,CAAT,CAAd;AACD;;AACD,QAAM,aAAa,GAAG,QAAQ,CAAC,CAAD,CAAR,KAAgB,CAAhB,IAAqB,QAAQ,CAAC,CAAD,CAAR,KAAgB,CAA3D;AACA,QAAM,CAAC,eAAD,EAAkB,aAAlB,IAAmC,4BAA4B,CACjE,CAAC,QAAQ,CAAC,QAAV,EAAoB,QAAQ,CAAC,OAA7B,CADiE,EAC1B,QAD0B,EAChB,WADgB,CAArE;AAEA,QAAM,YAAY,GAAG,aAAa,GAAG,GAAH,GAAS,OAA3C;AACA,QAAM,UAAU,GACZ,aAAa,GAAG,GAAH,GAAS,cAAc,CAAC,GAAD,EAAM,QAAN,EAAgB,eAAhB,CADxC;AAEA,QAAM,SAAS,GAAG,WAAW,KAAK,KAAhB,GACd,MAAM,YAAY,CACd,UADc,EACF,WADE,EACW,OADX,EACoB;AAAE;AADtB,IACsC,YADtC,CADJ,GAGd,MAAM,YAAY,CACd,UADc,EACF,WADE,EACW,OADX,EACoB;AAAE;AADtB,IACsC,YADtC,CAHtB;AAKA,QAAM,CAAC,GAAG,SAAS,EAAnB;AACA,QAAM,GAAG,GAAG,aAAa,GAAG,CAAH,GAAO,cAAc,CAAC,CAAD,EAAI,QAAJ,EAAc,aAAd,CAA9C;;AACA,MAAI,YAAJ,EAAkB;AAChB,WAAO,GAAG,CAAC,IAAJ,CAAS,GAAG,CAAC,KAAJ,CAAU,CAAV,CAAT,EAAuB,GAAG,CAAC,KAAJ,CAAU,CAAV,CAAvB,EAAqC,GAAG,CAAC,KAAJ,CAAU,CAAV,CAArC,CAAP;AACD;;AACD,SAAO,GAAP;AACD;AAED;;;;;;;;;;;;;;;;;;;;;;;AAqBA,SAAS,eAAT,CACI,EADJ,EAC6B,KAD7B,EAEI,MAFJ,EAEiC,UAFjC,EAGI,OAHJ,EAGsC,SAHtC,EAII,GAJJ,EAKI,eALJ,EAK4C;AAC1C,QAAM,GAAG,GAAG,eAAe,CAAC,EAAD,EAAK,IAAL,EAAW,iBAAX,CAA3B;AACA,QAAM,MAAM,GAAG,eAAe,CAAC,KAAD,EAAQ,OAAR,EAAiB,iBAAjB,CAA9B;AACA,QAAM,OAAO,GAAG,eAAe,CAAC,MAAD,EAAS,QAAT,EAAmB,iBAAnB,CAA/B;AACA,EAAA,IAAI,CAAC,MAAL,CACI,MAAM,CAAC,IAAP,KAAgB,GAAG,CAAC,IADxB,EAEI,MAAM,kBAAkB,MAAM,CAAC,IAAI,8BAA7B,GACF,IAAI,GAAG,CAAC,IAAI,GAHpB;;AAIA,MAAI,SAAS,IAAI,IAAjB,EAAuB;AACrB,IAAA,SAAS,GAAG,CAAC,CAAD,EAAI,CAAJ,CAAZ;AACD;;AACD,EAAA,IAAI,CAAC,MAAL,CACI,SAAS,CAAC,8BAAV,CAAyC,OAAzC,EAAkD,SAAlD,CADJ,EAEI,MACI,sEACA,eAAe,OAAO,mBAAmB,SAAS,GAJ1D;AAMA,EAAA,IAAI,CAAC,MAAL,CACI,GAAG,CAAC,IAAJ,KAAa,CADjB,EAEI,MAAM,2DAAA,GACF,GAAG,GAAG,CAAC,IAAI,GAHnB;AAIA,EAAA,IAAI,CAAC,MAAL,CACI,MAAM,CAAC,IAAP,KAAgB,CADpB,EAEI,MAAM,8DAAA,GACF,GAAG,MAAM,CAAC,IAAI,GAHtB;;AAIA,MAAI,eAAe,IAAI,IAAvB,EAA6B;AAC3B,IAAA,IAAI,CAAC,MAAL,CACI,IAAI,CAAC,KAAL,CAAW,GAAX,CADJ,EAEI,MAAM,+DAAA,GACF,mBAAmB,eAAe,gBAAgB,GAAG,GAH7D;AAID;;AAED,QAAM,QAAQ,GAAG,SAAS,CAAC,iBAAV,CACb,MAAM,CAAC,KADM,EACC,UADD,EACa,OADb,EACsB,SADtB,EACiC,GADjC,EACsC,eADtC,CAAjB;AAEA,QAAM,GAAG,GAAG,MAAM,CAAC,aAAP,CACR,OAAO,IAAI,OAAO,CAAC,eAAR,CAAwB,GAAxB,EAA6B,MAA7B,EAAqC,OAArC,EAA8C,QAA9C,CADH,EAER;AAAC,IAAA,GAAD;AAAM,IAAA;AAAN,GAFQ,CAAZ;AAGA,SAAO,GAAP;AACD;AAED;;;;;;;;;;;;;;;;;;AAgBA,SAAS,eAAT,CACI,EADJ,EACsB,KADtB,EAC2C,UAD3C,EAEI,OAFJ,EAEsC,SAFtC,EAGI,GAHJ,EAG8B;AAC5B,QAAM,GAAG,GAAG,eAAe,CAAC,EAAD,EAAK,IAAL,EAAW,iBAAX,CAA3B;AACA,QAAM,MAAM,GAAG,eAAe,CAAC,KAAD,EAAQ,OAAR,EAAiB,iBAAjB,CAA9B;AACA,EAAA,IAAI,CAAC,MAAL,CACI,MAAM,CAAC,IAAP,KAAgB,GAAG,CAAC,IADxB,EAEI,MAAM,kBAAkB,MAAM,CAAC,IAAI,gCAC/B,GAAG,CAAC,IAAI,GAHhB;;AAIA,MAAI,SAAS,IAAI,IAAjB,EAAuB;AACrB,IAAA,SAAS,GAAG,CAAC,CAAD,EAAI,CAAJ,CAAZ;AACD;;AACD,EAAA,IAAI,CAAC,MAAL,CACI,SAAS,CAAC,8BAAV,CAAyC,OAAzC,EAAkD,SAAlD,CADJ,EAEI,MACI,sEACA,eAAe,OAAO,mBAAmB,SAAS,GAJ1D;AAMA,MAAI,OAAO,GAAG,MAAd;AACA,MAAI,IAAI,GAAG,GAAX;AACA,MAAI,YAAY,GAAG,KAAnB;;AACA,MAAI,MAAM,CAAC,IAAP,KAAgB,CAApB,EAAuB;AACrB,IAAA,YAAY,GAAG,IAAf;AACA,IAAA,OAAO,GAAG,MAAM,CAAC,IAAP,CAAY,CAAZ,EAAe,MAAM,CAAC,KAAP,CAAa,CAAb,CAAf,EAAgC,MAAM,CAAC,KAAP,CAAa,CAAb,CAAhC,EAAiD,MAAM,CAAC,KAAP,CAAa,CAAb,CAAjD,CAAV;AACA,IAAA,IAAI,GAAG,GAAG,CAAC,IAAJ,CAAS,CAAT,EAAY,GAAG,CAAC,KAAJ,CAAU,CAAV,CAAZ,EAA0B,GAAG,CAAC,KAAJ,CAAU,CAAV,CAA1B,EAAwC,GAAG,CAAC,KAAJ,CAAU,CAAV,CAAxC,CAAP;AACD;;AAED,EAAA,IAAI,CAAC,MAAL,CACI,IAAI,CAAC,IAAL,KAAc,CADlB,EAEI,MAAM,2DAAA,GACF,GAAG,IAAI,CAAC,IAAI,GAHpB;AAIA,EAAA,IAAI,CAAC,MAAL,CACI,OAAO,CAAC,IAAR,KAAiB,CADrB,EAEI,MAAM,8DAAA,GACF,GAAG,OAAO,CAAC,IAAI,GAHvB;AAKA,QAAM,QAAQ,GAAG,SAAS,CAAC,iBAAV,CACb,OAAO,CAAC,KADK,EACE,UADF,EACc,OADd,EACuB,SADvB,EACkC,GADlC,CAAjB;AAEA,QAAM,GAAG,GAAG,MAAM,CAAC,aAAP,CACR,OAAO,IAAI,OAAO,CAAC,eAAR,CAAwB,IAAxB,EAA8B,OAA9B,EAAuC,QAAvC,CADH,EAER;AAAC,IAAA,IAAD;AAAO,IAAA;AAAP,GAFQ,CAAZ;;AAGA,MAAI,YAAJ,EAAkB;AAChB,WAAO,GAAG,CAAC,IAAJ,CAAS,GAAG,CAAC,KAAJ,CAAU,CAAV,CAAT,EAAuB,GAAG,CAAC,KAAJ,CAAU,CAAV,CAAvB,EAAqC,GAAG,CAAC,KAAJ,CAAU,CAAV,CAArC,CAAP;AACD;;AACD,SAAO,GAAP;AACD,C,CAED;AACA;AACA;;;AACA,SAAS,4BAAT,CACI,UADJ,EACkC,UADlC,EAEI,WAFJ,EAE2B;AACzB,QAAM,QAAQ,GAAG,WAAW,CAAC,GAAZ,CAAgB,CAAC,IAAI,CAAC,CAAC,CAAD,CAAtB,CAAjB;AACA,QAAM,UAAU,GAAG,WAAW,CAAC,GAAZ,CAAgB,CAAC,IAAI,CAAC,CAAC,CAAD,CAAtB,CAAnB;AACA,QAAM,cAAc,GAAG,UAAU,CAAC,MAAX,CAAkB,QAAlB,EAA4B,UAA5B,CAAvB;AACA,QAAM,WAAW,GAAG,UAAU,CAAC,GAAX,CAAe,CAAC,CAAD,EAAI,CAAJ,KAAU,CAAC,CAAC,GAAG,cAAc,CAAC,CAAD,CAAd,GAAoB,CAAzB,IAA8B,CAAvD,CAApB;AACA,QAAM,MAAM,GAAG,UAAU,CAAC,GAAX,CAAe,CAAC,CAAD,EAAI,CAAJ,KAAU,CAAC,GAAG,WAAW,CAAC,CAAD,CAAxC,CAAf;AACA,QAAM,QAAQ,GAAG,UAAU,CAAC,GAAX,CAAe,CAAC,CAAD,EAAI,CAAJ,KAAU,CAAC,QAAQ,CAAC,CAAD,CAAT,EAAc,MAAM,CAAC,CAAD,CAApB,CAAzB,CAAjB;AACA,QAAM,KAAK,GAAG,UAAU,CAAC,GAAX,CAAe,CAAC,CAAD,EAAI,CAAJ,KAAU,CAAC,CAAD,EAAI,WAAW,CAAC,CAAD,CAAf,CAAzB,CAAd;AACA,SAAO,CAAC,QAAD,EAAW,KAAX,CAAP;AACD,C,CAED;AACA;AACA;;;AACA,SAAS,4BAAT,CACI,WADJ,EACmC,QADnC,EAC6D;AAC3D;AACA;AACA,QAAM,kBAAkB,GAAG,WAAW,CAAC,GAAZ,CAAgB,CAAC,CAAD,EAAI,CAAJ,KAAS;AAClD,WAAO,CAAC,GAAG,CAAC,CAAC,GAAG,CAAL,KAAW,QAAQ,CAAC,CAAD,CAAR,GAAc,CAAzB,CAAX;AACD,GAF0B,CAA3B;AAGA,QAAM,aAAa,GAAG,kBAAkB,CAAC,GAAnB,CAAuB,CAAC,IAAI,CAAC,GAAG,CAAhC,CAAtB,CAN2D,CAQ3D;AACA;;AACA,QAAM,aAAa,GAAG,aAAa,CAAC,GAAd,CAAkB,CAAC,IAAI,IAAI,CAAC,KAAL,CAAW,CAAC,GAAG,CAAf,CAAvB,CAAtB;AACA,QAAM,WAAW,GAAG,aAAa,CAAC,GAAd,CAAkB,CAAC,CAAD,EAAI,CAAJ,KAAU,CAAC,GAAG,aAAa,CAAC,CAAD,CAA7C,CAApB;AACA,SAAO,aAAa,CAAC,GAAd,CAAkB,CAAC,CAAD,EAAI,CAAJ,KAAS;AAChC,WAAO,CAAC,aAAa,CAAC,CAAD,CAAd,EAAmB,WAAW,CAAC,CAAD,CAA9B,CAAP;AACD,GAFM,CAAP;AAGD;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0CA;;;AACA,SAAS,UAAT,CACI,CADJ,EAEI,UAFJ,EAGI,OAHJ,EAII,GAJJ,EAKI,eALJ,EAMI,UAAA,GAA8B,OANlC,EAOI,SAPJ,EAO+C;AAE7C,QAAM,EAAE,GAAG,eAAe,CAAC,CAAD,EAAI,GAAJ,EAAS,WAAT,EAAsB,SAAtB,CAA1B;AAEA,MAAI,GAAG,GAAG,EAAV;AACA,MAAI,YAAY,GAAG,KAAnB;;AACA,MAAI,EAAE,CAAC,IAAH,KAAY,CAAhB,EAAmB;AACjB,IAAA,YAAY,GAAG,IAAf;AACA,IAAA,GAAG,GAAG,EAAE,CAAC,IAAH,CAAQ,CAAR,EAAW,EAAE,CAAC,KAAH,CAAS,CAAT,CAAX,EAAwB,EAAE,CAAC,KAAH,CAAS,CAAT,CAAxB,EAAqC,EAAE,CAAC,KAAH,CAAS,CAAT,CAArC,EAAkD,EAAE,CAAC,KAAH,CAAS,CAAT,CAAlD,CAAN;AACD;;AAED,MAAI,SAAS,IAAI,IAAjB,EAAuB;AACrB,IAAA,SAAS,GAAG,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,CAAZ;AACD;;AACD,EAAA,IAAI,CAAC,MAAL,CACI,GAAG,CAAC,IAAJ,KAAa,CADjB,EAEI,MAAM,qDAAqD,GAAG,CAAC,IAAI,GAFvE;AAGA,EAAA,IAAI,CAAC,MAAL,CACI,UAAU,KAAK,OADnB,EAEI,MAAM,yDAAA,GACF,yBAAyB,UAAU,EAH3C;AAIA,EAAA,IAAI,CAAC,MAAL,CACI,SAAS,CAAC,8BAAV,CAAyC,OAAzC,EAAkD,SAAlD,CADJ,EAEI,MAAM,gEACF,eAAe,OAAO,mBAAmB,SAAS,GAH1D;;AAIA,MAAI,eAAe,IAAI,IAAvB,EAA6B;AAC3B,IAAA,IAAI,CAAC,MAAL,CACI,IAAI,CAAC,KAAL,CAAW,GAAX,CADJ,EAEI,MAAM,yDAAA,GACF,mBAAmB,eAAe,gBAAgB,GAAG,GAH7D;AAID;;AAED,QAAM,QAAQ,GAAG,SAAS,CAAC,iBAAV,CACb,GAAG,CAAC,KADS,EACF,UADE,EACU,OADV,EACmB,SADnB,EAC8B,GAD9B,EACmC,eADnC,EAEb,UAFa,CAAjB;;AAIA,QAAM,IAAI,GAAI,EAAD,IAAiB;AAC5B,WAAO;AACL,MAAA,CAAC,EAAE,MAAM,iBAAiB,CACtB,EADsB,EAClB,GADkB,EACb,UADa,EACD,OADC,EACQ,SADR,EACmB,GADnB,EACwB,eADxB;AADrB,KAAP;AAID,GALD;;AAOA,MAAI,GAAG,GAAG,MAAM,CAAC,aAAP,CACN,OAAO,IAAI,OAAO,CAAC,SAAR,CAAkB,GAAlB,EAAuB,QAAvB,CADL,EACuC;AAAC,IAAA,CAAC,EAAE;AAAJ,GADvC,EACiD,IADjD,CAAV;AAEA,EAAA,GAAG,GAAG,GAAG,CAAC,IAAJ,CAAS,GAAG,CAAC,KAAb,CAAN;;AACA,MAAI,YAAJ,EAAkB;AAChB,WAAO,GAAG,CAAC,IAAJ,CAAS,GAAG,CAAC,KAAJ,CAAU,CAAV,CAAT,EAAuB,GAAG,CAAC,KAAJ,CAAU,CAAV,CAAvB,EAAqC,GAAG,CAAC,KAAJ,CAAU,CAAV,CAArC,EAAmD,GAAG,CAAC,KAAJ,CAAU,CAAV,CAAnD,CAAP;AAED;;AAED,SAAO,GAAP;AACD;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6BA,SAAS,iBAAT,CACI,EADJ,EACsB,KADtB,EAEI,UAFJ,EAGI,OAHJ,EAII,SAJJ,EAIgD,GAJhD,EAKI,eALJ,EAK4C;AAC1C,QAAM,GAAG,GAAG,eAAe,CAAC,EAAD,EAAK,IAAL,EAAW,mBAAX,CAA3B;AACA,QAAM,MAAM,GAAG,eAAe,CAAC,KAAD,EAAQ,OAAR,EAAiB,mBAAjB,CAA9B;AAEA,MAAI,IAAI,GAAG,GAAX;AACA,MAAI,OAAO,GAAG,MAAd;AACA,MAAI,YAAY,GAAG,KAAnB;;AACA,MAAI,MAAM,CAAC,IAAP,KAAgB,CAApB,EAAuB;AACrB,IAAA,YAAY,GAAG,IAAf;AACA,IAAA,IAAI,GAAG,GAAG,CAAC,IAAJ,CAAS,CAAT,EAAY,GAAG,CAAC,KAAJ,CAAU,CAAV,CAAZ,EAA0B,GAAG,CAAC,KAAJ,CAAU,CAAV,CAA1B,EAAwC,GAAG,CAAC,KAAJ,CAAU,CAAV,CAAxC,EAAsD,GAAG,CAAC,KAAJ,CAAU,CAAV,CAAtD,CAAP;AACA,IAAA,OAAO,GAAG,MAAM,CAAC,IAAP,CACN,CADM,EACH,MAAM,CAAC,KAAP,CAAa,CAAb,CADG,EACc,MAAM,CAAC,KAAP,CAAa,CAAb,CADd,EAC+B,MAAM,CAAC,KAAP,CAAa,CAAb,CAD/B,EACgD,MAAM,CAAC,KAAP,CAAa,CAAb,CADhD,CAAV;AAED;;AAED,EAAA,IAAI,CAAC,MAAL,CACI,IAAI,CAAC,IAAL,KAAc,CADlB,EAEI,MAAM,6DAAA,GACF,GAAG,IAAI,CAAC,IAAI,GAHpB;AAIA,EAAA,IAAI,CAAC,MAAL,CACI,OAAO,CAAC,IAAR,KAAiB,CADrB,EAEI,MAAM,gEAAA,GACF,GAAG,OAAO,CAAC,IAAI,GAHvB;;AAIA,MAAI,SAAS,IAAI,IAAjB,EAAuB;AACrB,IAAA,SAAS,GAAG,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,CAAZ;AACD;;AACD,EAAA,IAAI,CAAC,MAAL,CACI,SAAS,CAAC,8BAAV,CAAyC,OAAzC,EAAkD,SAAlD,CADJ,EAEI,MAAM,6DACF,0BAA0B,OAAO,mBAAmB,SAAS,GAHrE;;AAIA,MAAI,eAAe,IAAI,IAAvB,EAA6B;AAC3B,IAAA,IAAI,CAAC,MAAL,CACI,IAAI,CAAC,KAAL,CAAW,GAAX,CADJ,EAEI,MAAM,0DAAA,GACF,0BAA0B,eAAe,gBAAgB,GAAG,GAHpE;AAID;;AAED,QAAM,QAAQ,GAAG,SAAS,CAAC,iBAAV,CACb,OAAO,CAAC,KADK,EACE,UADF,EACc,OADd,EACuB,SADvB,EACkC,GADlC,EACuC,eADvC,CAAjB;AAEA,QAAM,GAAG,GAAG,MAAM,CAAC,aAAP,CACR,OAAO,IAAI,OAAO,CAAC,iBAAR,CAA0B,IAA1B,EAAgC,OAAhC,EAAyC,QAAzC,CADH,EAER;AAAC,IAAA,IAAD;AAAO,IAAA;AAAP,GAFQ,CAAZ;;AAGA,MAAI,YAAJ,EAAkB;AAChB,WAAO,GAAG,CAAC,IAAJ,CAAS,GAAG,CAAC,KAAJ,CAAU,CAAV,CAAT,EAAuB,GAAG,CAAC,KAAJ,CAAU,CAAV,CAAvB,EAAqC,GAAG,CAAC,KAAJ,CAAU,CAAV,CAArC,EAAmD,GAAG,CAAC,KAAJ,CAAU,CAAV,CAAnD,CAAP;AAED;;AAED,SAAO,GAAP;AACD;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0CA;;;AACA,SAAS,UAAT,CACI,CADJ,EACqB,UADrB,EAEI,OAFJ,EAE8C,GAF9C,EAGI,eAHJ,EAII,UAAA,GAA8B,OAJlC,EAKI,SALJ,EAK+C;AAC7C,QAAM,EAAE,GAAG,eAAe,CAAC,CAAD,EAAI,GAAJ,EAAS,WAAT,CAA1B;AAEA,MAAI,GAAG,GAAG,EAAV;AACA,MAAI,YAAY,GAAG,KAAnB;;AACA,MAAI,EAAE,CAAC,IAAH,KAAY,CAAhB,EAAmB;AACjB,IAAA,YAAY,GAAG,IAAf;AACA,IAAA,GAAG,GAAG,EAAE,CAAC,IAAH,CAAQ,CAAR,EAAW,EAAE,CAAC,KAAH,CAAS,CAAT,CAAX,EAAwB,EAAE,CAAC,KAAH,CAAS,CAAT,CAAxB,EAAqC,EAAE,CAAC,KAAH,CAAS,CAAT,CAArC,EAAkD,EAAE,CAAC,KAAH,CAAS,CAAT,CAAlD,CAAN;AACD;;AAED,MAAI,SAAS,IAAI,IAAjB,EAAuB;AACrB,IAAA,SAAS,GAAG,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,CAAZ;AACD;;AACD,EAAA,IAAI,CAAC,MAAL,CACI,GAAG,CAAC,IAAJ,KAAa,CADjB,EAEI,MAAM,qDAAqD,GAAG,CAAC,IAAI,GAFvE;AAGA,EAAA,IAAI,CAAC,MAAL,CACI,UAAU,KAAK,OADnB,EAEI,MAAM,yDAAA,GACF,yBAAyB,UAAU,EAH3C;AAIA,EAAA,IAAI,CAAC,MAAL,CACI,SAAS,CAAC,8BAAV,CAAyC,OAAzC,EAAkD,SAAlD,CADJ,EAEI,MAAM,gEACF,eAAe,OAAO,mBAAmB,SAAS,GAH1D;;AAIA,MAAI,eAAe,IAAI,IAAvB,EAA6B;AAC3B,IAAA,IAAI,CAAC,MAAL,CACI,IAAI,CAAC,KAAL,CAAW,GAAX,CADJ,EAEI,MAAM,yDAAA,GACF,mBAAmB,eAAe,gBAAgB,GAAG,GAH7D;AAID;;AAED,QAAM,QAAQ,GAAG,SAAS,CAAC,iBAAV,CACb,GAAG,CAAC,KADS,EACF,UADE,EACU,OADV,EACmB,SADnB,EAC8B,GAD9B,EACmC,eADnC,EAEb,UAFa,CAAjB;;AAIA,QAAM,IAAI,GAAG,CAAC,EAAD,EAAe,KAAf,KAAkC;AAC7C,UAAM,CAAC,GAAD,EAAM,CAAN,IAAW,KAAjB;AACA,WAAO;AACL,MAAA,CAAC,EAAE,MAAM,iBAAiB,CACtB,EADsB,EAClB,GADkB,EACD,CADC,EACc,UADd,EAC0B,OAD1B,EACmC,SADnC,EAEtB,GAFsB,EAEjB,eAFiB;AADrB,KAAP;AAKD,GAPD;;AASA,QAAM,GAAG,GAAG,MAAM,CAAC,aAAP,CAAqB,CAAC,OAAD,EAAU,IAAV,KAAkB;AACjD,UAAM,CAAC,GAAG,OAAO,CAAC,SAAR,CAAkB,GAAlB,EAAuB,QAAvB,CAAV;AACA,IAAA,IAAI,CAAC,CAAC,GAAD,EAAM,CAAN,CAAD,CAAJ;AACA,WAAO,CAAP;AACD,GAJW,EAIT;AAAC,IAAA,CAAC,EAAE;AAAJ,GAJS,EAIC,IAJD,CAAZ;;AAKA,MAAI,YAAJ,EAAkB;AAChB,WAAO,GAAG,CAAC,IAAJ,CAAS,GAAG,CAAC,KAAJ,CAAU,CAAV,CAAT,EAAuB,GAAG,CAAC,KAAJ,CAAU,CAAV,CAAvB,EAAqC,GAAG,CAAC,KAAJ,CAAU,CAAV,CAArC,EAAmD,GAAG,CAAC,KAAJ,CAAU,CAAV,CAAnD,CAAP;AAED;;AAED,SAAO,GAAP;AACD;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+BA,SAAS,iBAAT,CACI,EADJ,EACsB,KADtB,EAC2C,MAD3C,EAEI,UAFJ,EAGI,OAHJ,EAII,SAJJ,EAIgD,GAJhD,EAKI,eALJ,EAK4C;AAC1C,QAAM,GAAG,GAAG,eAAe,CAAC,EAAD,EAAK,IAAL,EAAW,mBAAX,CAA3B;AACA,QAAM,MAAM,GAAG,eAAe,CAAC,KAAD,EAAQ,OAAR,EAAiB,mBAAjB,CAA9B;AACA,QAAM,OAAO,GAAG,eAAe,CAAC,MAAD,EAAS,QAAT,EAAmB,mBAAnB,CAA/B;AAEA,MAAI,IAAI,GAAG,GAAX;AACA,MAAI,OAAO,GAAG,MAAd;AACA,MAAI,QAAQ,GAAG,OAAf;AACA,MAAI,YAAY,GAAG,KAAnB;;AACA,MAAI,MAAM,CAAC,IAAP,KAAgB,CAApB,EAAuB;AACrB,IAAA,YAAY,GAAG,IAAf;AACA,IAAA,IAAI,GAAG,GAAG,CAAC,IAAJ,CAAS,CAAT,EAAY,GAAG,CAAC,KAAJ,CAAU,CAAV,CAAZ,EAA0B,GAAG,CAAC,KAAJ,CAAU,CAAV,CAA1B,EAAwC,GAAG,CAAC,KAAJ,CAAU,CAAV,CAAxC,EAAsD,GAAG,CAAC,KAAJ,CAAU,CAAV,CAAtD,CAAP;AACA,IAAA,OAAO,GAAG,MAAM,CAAC,IAAP,CACN,CADM,EACH,MAAM,CAAC,KAAP,CAAa,CAAb,CADG,EACc,MAAM,CAAC,KAAP,CAAa,CAAb,CADd,EAC+B,MAAM,CAAC,KAAP,CAAa,CAAb,CAD/B,EACgD,MAAM,CAAC,KAAP,CAAa,CAAb,CADhD,CAAV;AAEA,IAAA,QAAQ,GAAG,OAAO,CAAC,IAAR,CACP,CADO,EACJ,OAAO,CAAC,KAAR,CAAc,CAAd,CADI,EACc,OAAO,CAAC,KAAR,CAAc,CAAd,CADd,EACgC,OAAO,CAAC,KAAR,CAAc,CAAd,CADhC,EAEP,OAAO,CAAC,KAAR,CAAc,CAAd,CAFO,CAAX;AAGD;;AAED,EAAA,IAAI,CAAC,MAAL,CACI,IAAI,CAAC,IAAL,KAAc,CADlB,EAEI,MAAM,6DAAA,GACF,GAAG,IAAI,CAAC,IAAI,GAHpB;AAIA,EAAA,IAAI,CAAC,MAAL,CACI,OAAO,CAAC,IAAR,KAAiB,CADrB,EAEI,MAAM,gEAAA,GACF,GAAG,OAAO,CAAC,IAAI,GAHvB;AAIA,EAAA,IAAI,CAAC,MAAL,CACI,QAAQ,CAAC,IAAT,KAAkB,CADtB,EAEI,MAAM,iEAAA,GACF,GAAG,QAAQ,CAAC,IAAI,GAHxB;;AAIA,MAAI,SAAS,IAAI,IAAjB,EAAuB;AACrB,IAAA,SAAS,GAAG,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,CAAZ;AACD;;AACD,EAAA,IAAI,CAAC,MAAL,CACI,SAAS,CAAC,8BAAV,CAAyC,OAAzC,EAAkD,SAAlD,CADJ,EAEI,MAAM,6DACF,0BAA0B,OAAO,mBAAmB,SAAS,GAHrE;;AAIA,MAAI,eAAe,IAAI,IAAvB,EAA6B;AAC3B,IAAA,IAAI,CAAC,MAAL,CACI,IAAI,CAAC,KAAL,CAAW,GAAX,CADJ,EAEI,MAAM,0DAAA,GACF,0BAA0B,eAAe,gBAAgB,GAAG,GAHpE;AAID;;AAED,QAAM,QAAQ,GAAG,SAAS,CAAC,iBAAV,CACb,OAAO,CAAC,KADK,EACE,UADF,EACc,OADd,EACuB,SADvB,EACkC,GADlC,EACuC,eADvC,CAAjB;AAEA,QAAM,GAAG,GAAG,MAAM,CAAC,aAAP,CACR,OAAO,IAAI,OAAO,CAAC,iBAAR,CAA0B,IAA1B,EAAgC,OAAhC,EAAyC,QAAzC,EAAmD,QAAnD,CADH,EAER;AAAC,IAAA,IAAD;AAAO,IAAA;AAAP,GAFQ,CAAZ;;AAIA,MAAI,YAAJ,EAAkB;AAChB,WAAO,GAAG,CAAC,IAAJ,CAAS,GAAG,CAAC,KAAJ,CAAU,CAAV,CAAT,EAAuB,GAAG,CAAC,KAAJ,CAAU,CAAV,CAAvB,EAAqC,GAAG,CAAC,KAAJ,CAAU,CAAV,CAArC,EAAmD,GAAG,CAAC,KAAJ,CAAU,CAAV,CAAnD,CAAP;AAED;;AAED,SAAO,GAAP;AACD;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+BA;;AACA;;;AACA,SAAS,kBAAT,CACI,CADJ,EACqB,UADrB,EAEI,OAFJ,EAEsC,GAFtC,EAGI,mBAAmB,GAAG,KAH1B,EAG+B;AAC7B,QAAM,EAAE,GAAG,eAAe,CAAC,CAAD,EAAI,GAAJ,EAAS,mBAAT,CAA1B;AAEA,QAAM,KAAK,GAAG;AAAC,IAAA,UAAD;AAAa,IAAA,OAAb;AAAsB,IAAA,GAAtB;AAA2B,IAAA;AAA3B,GAAd;AAEA,QAAM,MAAM,GACR,MAAM,CAAC,SAAP,CAAiB,mBAAjB,EAAsC;AAAC,IAAA,CAAC,EAAE;AAAJ,GAAtC,EAA+C,KAA/C,CADJ;AAGA,SAAO;AAAC,IAAA,MAAM,EAAE,MAAM,CAAC,CAAD,CAAf;AAAoB,IAAA,OAAO,EAAE,MAAM,CAAC,CAAD;AAAnC,GAAP;AACD;;AAED,OAAO,MAAM,OAAO,GAAG,EAAE,CAAC;AAAC,EAAA;AAAD,CAAD,CAAlB;AACP,OAAO,MAAM,OAAO,GAAG,EAAE,CAAC;AAAC,EAAA;AAAD,CAAD,CAAlB;AACP,OAAO,MAAM,IAAI,GAAG,EAAE,CAAC;AAAC,EAAA;AAAD,CAAD,CAAf;AACP,OAAO,MAAM,SAAS,GAAG,EAAE,CAAC;AAAC,EAAA;AAAD,CAAD,CAApB;AACP,OAAO,MAAM,SAAS,GAAG,EAAE,CAAC;AAAC,EAAA;AAAD,CAAD,CAApB;AACP,OAAO,MAAM,iBAAiB,GAAG,EAAE,CAAC;AAAC,EAAA;AAAD,CAAD,CAA5B","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { convertToTensor } from '../tensor_util_env';\nimport * as util from '../util';\nimport { batchToSpaceND } from './batch_to_space_nd';\nimport * as conv_util from './conv_util';\nimport { op } from './operation';\nimport { spaceToBatchND } from './space_to_batch_nd';\n/**\n * Computes the 2D max pooling of an image.\n *\n * @param x The input tensor, of rank 4 or rank 3 of shape\n *     `[batch, height, width, inChannels]`. If rank 3, batch of 1 is assumed.\n * @param filterSize The filter size: `[filterHeight, filterWidth]`. If\n *     `filterSize` is a single number, then `filterHeight == filterWidth`.\n * @param strides The strides of the pooling: `[strideHeight, strideWidth]`. If\n *     `strides` is a single number, then `strideHeight == strideWidth`.\n * @param dilations The dilation rates: `[dilationHeight, dilationWidth]`\n *     in which we sample input values across the height and width dimensions\n *     in dilated pooling. Defaults to `[1, 1]`. If `dilations` is a single\n *     number, then `dilationHeight == dilationWidth`. If it is greater than\n *     1, then all values of `strides` must be 1.\n * @param pad The type of padding algorithm.\n *    - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *    - `valid`: output will be smaller than input if filter is larger\n *       than 1x1.\n *    - For more info, see this guide:\n *     [https://www.tensorflow.org/api_guides/python/nn#Convolution](\n *          https://www.tensorflow.org/api_guides/python/nn#Convolution)\n * @param dimRoundingMode The rounding mode used when computing output\n *     dimensions if pad is a number. If none is provided, it will not round\n *     and error if the output is of fractional size.\n */\nfunction maxPoolImpl_(x, filterSize, strides, dilations, pad, dimRoundingMode) {\n    const $x = convertToTensor(x, 'x', 'maxPool');\n    let x4D = $x;\n    let reshapedTo4D = false;\n    if ($x.rank === 3) {\n        reshapedTo4D = true;\n        x4D = $x.as4D(1, $x.shape[0], $x.shape[1], $x.shape[2]);\n    }\n    if (dilations == null) {\n        dilations = [1, 1];\n    }\n    util.assert(x4D.rank === 4, () => `Error in maxPool: input must be rank 4 but got rank ${x4D.rank}.`);\n    util.assert(conv_util.eitherStridesOrDilationsAreOne(strides, dilations), () => 'Error in maxPool: Either strides or dilations must be 1. ' +\n        `Got strides ${strides} and dilations '${dilations}'`);\n    if (dimRoundingMode != null) {\n        util.assert(util.isInt(pad), () => `Error in maxPool: pad must be an integer when using, ` +\n            `dimRoundingMode ${dimRoundingMode} but got pad ${pad}.`);\n    }\n    const convInfo = conv_util.computePool2DInfo(x4D.shape, filterSize, strides, dilations, pad, dimRoundingMode);\n    if (convInfo.filterWidth === 1 && convInfo.filterHeight === 1 &&\n        util.arraysEqual(convInfo.inShape, convInfo.outShape)) {\n        return $x.clone();\n    }\n    const grad = (dy, saved) => {\n        const [x4D, y] = saved;\n        return {\n            x: () => maxPoolBackprop(dy, x4D, y, filterSize, strides, dilations, pad)\n        };\n    };\n    const inputsToSave = [x4D];\n    const res = ENGINE.runKernelFunc((backend, save) => {\n        const y = backend.maxPool(x4D, convInfo);\n        save([x4D, y]);\n        return y;\n    }, { x: x4D }, grad, 'MaxPool', convInfo, inputsToSave);\n    if (reshapedTo4D) {\n        return res.as3D(res.shape[1], res.shape[2], res.shape[3]);\n    }\n    return res;\n}\n/**\n * Computes the 2D max pooling of an image.\n *\n * @param x The input tensor, of rank 4 or rank 3 of shape\n *     `[batch, height, width, inChannels]`. If rank 3, batch of 1 is assumed.\n * @param filterSize The filter size: `[filterHeight, filterWidth]`. If\n *     `filterSize` is a single number, then `filterHeight == filterWidth`.\n * @param strides The strides of the pooling: `[strideHeight, strideWidth]`. If\n *     `strides` is a single number, then `strideHeight == strideWidth`.\n * @param pad The type of padding algorithm.\n *    - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *    - `valid`: output will be smaller than input if filter is larger\n *       than 1x1.\n *    - For more info, see this guide:\n *     [https://www.tensorflow.org/api_guides/python/nn#Convolution](\n *          https://www.tensorflow.org/api_guides/python/nn#Convolution)\n * @param dimRoundingMode The rounding mode used when computing output\n *     dimensions if pad is a number. If none is provided, it will not round\n *     and error if the output is of fractional size.\n */\n/** @doc {heading: 'Operations', subheading: 'Convolution'} */\nfunction maxPool_(x, filterSize, strides, pad, dimRoundingMode) {\n    return maxPoolImpl_(x, filterSize, strides, 1, pad, dimRoundingMode);\n}\n/**\n * Computes the 2D average pooling of an image.\n *\n * @param x The input tensor, of rank 4 or rank 3 of shape\n *     `[batch, height, width, inChannels]`. If rank 3, batch of 1 is assumed.\n * @param filterSize The filter size: `[filterHeight, filterWidth]`. If\n *     `filterSize` is a single number, then `filterHeight == filterWidth`.\n * @param strides The strides of the pooling: `[strideHeight, strideWidth]`. If\n *     `strides` is a single number, then `strideHeight == strideWidth`.\n * @param dilations The dilation rates: `[dilationHeight, dilationWidth]`\n *     in which we sample input values across the height and width dimensions\n *     in dilated pooling. Defaults to `[1, 1]`. If `dilations` is a single\n *     number, then `dilationHeight == dilationWidth`. If it is greater than\n *     1, then all values of `strides` must be 1.\n * @param pad The type of padding algorithm:\n *    - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *    - `valid`: output will be smaller than input if filter is larger\n *       than 1x1.\n *    - For more info, see this guide:\n *     [https://www.tensorflow.org/api_guides/python/nn#Convolution](\n *         https://www.tensorflow.org/api_guides/python/nn#Convolution)\n * @param dimRoundingMode The rounding mode used when computing output\n *     dimensions if pad is a number. If none is provided, it will not round\n *     and error if the output is of fractional size.\n */\nfunction avgPoolImpl_(x, filterSize, strides, dilations, pad, dimRoundingMode) {\n    const $x = convertToTensor(x, 'x', 'avgPool', 'float32');\n    if (dilations == null) {\n        dilations = [1, 1];\n    }\n    util.assert(conv_util.eitherStridesOrDilationsAreOne(strides, dilations), () => 'Error in avgPool: Either strides or dilations must be 1. ' +\n        `Got strides ${strides} and dilations '${dilations}'`);\n    let x4D = $x;\n    let reshapedTo4D = false;\n    if ($x.rank === 3) {\n        reshapedTo4D = true;\n        x4D = $x.as4D(1, $x.shape[0], $x.shape[1], $x.shape[2]);\n    }\n    util.assert(x4D.rank === 4, () => `Error in avgPool: x must be rank 4 but got rank ${x4D.rank}.`);\n    if (dimRoundingMode != null) {\n        util.assert(util.isInt(pad), () => `Error in avgPool: pad must be an integer when using, ` +\n            `dimRoundingMode ${dimRoundingMode} but got pad ${pad}.`);\n    }\n    const convInfo = conv_util.computePool2DInfo(x4D.shape, filterSize, strides, dilations, pad, dimRoundingMode);\n    if (convInfo.filterWidth === 1 && convInfo.filterHeight === 1 &&\n        util.arraysEqual(convInfo.inShape, convInfo.outShape)) {\n        return $x.clone();\n    }\n    const grad = (dy) => {\n        return {\n            x: () => avgPoolBackprop(dy, x4D, filterSize, strides, dilations, pad)\n        };\n    };\n    let res = ENGINE.runKernelFunc(backend => backend.avgPool(x4D, convInfo), { x: x4D }, grad, 'AvgPool', convInfo);\n    res = res.cast($x.dtype);\n    if (reshapedTo4D) {\n        return res.as3D(res.shape[1], res.shape[2], res.shape[3]);\n    }\n    return res;\n}\n/**\n * Computes the 2D average pooling of an image.\n *\n * @param x The input tensor, of rank 4 or rank 3 of shape\n *     `[batch, height, width, inChannels]`. If rank 3, batch of 1 is assumed.\n * @param filterSize The filter size: `[filterHeight, filterWidth]`. If\n *     `filterSize` is a single number, then `filterHeight == filterWidth`.\n * @param strides The strides of the pooling: `[strideHeight, strideWidth]`. If\n *     `strides` is a single number, then `strideHeight == strideWidth`.\n * @param pad The type of padding algorithm:\n *    - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *    - `valid`: output will be smaller than input if filter is larger\n *       than 1x1.\n *    - For more info, see this guide:\n *     [https://www.tensorflow.org/api_guides/python/nn#Convolution](\n *         https://www.tensorflow.org/api_guides/python/nn#Convolution)\n * @param dimRoundingMode The rounding mode used when computing output\n *     dimensions if pad is a number. If none is provided, it will not round\n *     and error if the output is of fractional size.\n */\n/** @doc {heading: 'Operations', subheading: 'Convolution'} */\nfunction avgPool_(x, filterSize, strides, pad, dimRoundingMode) {\n    return avgPoolImpl_(x, filterSize, strides, 1, pad, dimRoundingMode);\n}\n/**\n * Performs an N-D pooling operation\n *\n * @param input The input tensor, of rank 4 or rank 3 of shape\n *     `[batch, height, width, inChannels]`. If rank 3, batch of 1 is assumed.\n * @param windowShape The filter size: `[filterHeight, filterWidth]`. If\n *     `filterSize` is a single number, then `filterHeight == filterWidth`.\n * @param poolingType The type of pooling, either 'max' or 'avg'.\n * @param pad The type of padding algorithm:\n *    - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *    - `valid`: output will be smaller than input if filter is larger\n *       than 1x1.\n *    - For more info, see this guide:\n *     [https://www.tensorflow.org/api_guides/python/nn#Convolution](\n *         https://www.tensorflow.org/api_guides/python/nn#Convolution)\n * @param dilations The dilation rates: `[dilationHeight, dilationWidth]`\n *     in which we sample input values across the height and width dimensions\n *     in dilated pooling. Defaults to `[1, 1]`. If `dilationRate` is a single\n *     number, then `dilationHeight == dilationWidth`. If it is greater than\n *     1, then all values of `strides` must be 1.\n * @param strides The strides of the pooling: `[strideHeight, strideWidth]`. If\n *     `strides` is a single number, then `strideHeight == strideWidth`.\n */\n/** @doc {heading: 'Operations', subheading: 'Convolution'} */\nfunction pool_(input, windowShape, poolingType, pad, dilations, strides) {\n    if (dilations == null) {\n        dilations = [1, 1];\n    }\n    if (strides == null) {\n        strides = 1;\n    }\n    if (pad === 0) {\n        pad = 'valid';\n    }\n    const $x = convertToTensor(input, 'x', 'maxPool');\n    let x4D = $x;\n    let reshapedTo4D = false;\n    if ($x.rank === 3) {\n        reshapedTo4D = true;\n        x4D = $x.as4D(1, $x.shape[0], $x.shape[1], $x.shape[2]);\n    }\n    util.assert(conv_util.eitherStridesOrDilationsAreOne(strides, dilations), () => 'Error in pool: Either strides or dilations must be 1. ' +\n        `Got strides ${strides} and dilations '${dilations}'`);\n    const convInfo = conv_util.computePool2DInfo(x4D.shape, windowShape, strides, dilations, pad);\n    const dilation = [convInfo.dilationHeight, convInfo.dilationWidth];\n    // The following implementation does batchToSpace(pool(spaceToBatch(x)))\n    // whenever dilation > 1 since the TF kernels do not support dilation > 1.\n    // tslint:disable-next-line:max-line-length\n    // https://github.com/tensorflow/tensorflow/blob/50f6bb67dc98c9b74630b6047aae7a4f8a40fd02/tensorflow/python/ops/nn_ops.py#L1037\n    let basePadding;\n    if (pad === 'same') {\n        basePadding = withSpaceToBatchBasePaddings([convInfo.filterHeight, convInfo.filterWidth], dilation);\n    }\n    else {\n        basePadding = [[0, 0], [0, 0]];\n    }\n    const isDilationOne = dilation[0] === 1 && dilation[1] === 1;\n    const [adjustedPadding, adjustedCrops] = requiredSpaceToBatchPaddings([convInfo.inHeight, convInfo.inWidth], dilation, basePadding);\n    const convertedPad = isDilationOne ? pad : 'valid';\n    const convertedX = isDilationOne ? x4D : spaceToBatchND(x4D, dilation, adjustedPadding);\n    const forwardOp = poolingType === 'avg' ?\n        () => avgPoolImpl_(convertedX, windowShape, strides, 1 /* dilation */, convertedPad) :\n        () => maxPoolImpl_(convertedX, windowShape, strides, 1 /* dilation */, convertedPad);\n    const y = forwardOp();\n    const res = isDilationOne ? y : batchToSpaceND(y, dilation, adjustedCrops);\n    if (reshapedTo4D) {\n        return res.as3D(res.shape[1], res.shape[2], res.shape[3]);\n    }\n    return res;\n}\n/**\n * Computes the backprop of a 2D max pool.\n *\n * @param dy The dy error, of rank 4 or rank 3 of shape\n *     [batchSize, height, width, channels]. If rank 3, batch of 1 is\n * assumed.\n * @param input The original input image, of rank 4, of shape\n *     [batchSize, height, width, channels].\n * @param output The original output image, of rank 4, of shape\n *     [batchSize, outHeight, outWidth, channels].\n * @param filterSize The filter size: `[filterHeight, filterWidth]`. If\n *     `filterSize` is a single number, then `filterHeight == filterWidth`.\n * @param strides The strides of the pooling: `[strideHeight, strideWidth]`. If\n *     `strides` is a single number, then `strideHeight == strideWidth`.\n * @param pad A string from: 'same', 'valid'. The type of padding algorithm\n *     used in the forward prop of the op.\n * @param dimRoundingMode A string from: 'ceil', 'round', 'floor'. The\n *     rounding mode used when computing output dimensions if pad is a\n *     number. If none is provided, it will not round and error if the output\n *     is of fractional size.\n */\nfunction maxPoolBackprop(dy, input, output, filterSize, strides, dilations, pad, dimRoundingMode) {\n    const $dy = convertToTensor(dy, 'dy', 'maxPoolBackprop');\n    const $input = convertToTensor(input, 'input', 'maxPoolBackprop');\n    const $output = convertToTensor(output, 'output', 'maxPoolBackprop');\n    util.assert($input.rank === $dy.rank, () => `Rank of input (${$input.rank}) does not match rank of dy ` +\n        `(${$dy.rank})`);\n    if (dilations == null) {\n        dilations = [1, 1];\n    }\n    util.assert(conv_util.eitherStridesOrDilationsAreOne(strides, dilations), () => 'Error in maxPoolBackProp: Either strides or dilations must be 1. ' +\n        `Got strides ${strides} and dilations '${dilations}'`);\n    util.assert($dy.rank === 4, () => `Error in maxPoolBackprop: dy must be rank 4 but got rank ` +\n        `${$dy.rank}.`);\n    util.assert($input.rank === 4, () => `Error in maxPoolBackprop: input must be rank 4 but got rank ` +\n        `${$input.rank}.`);\n    if (dimRoundingMode != null) {\n        util.assert(util.isInt(pad), () => `Error in maxPoolBackprop: pad must be an integer when using, ` +\n            `dimRoundingMode ${dimRoundingMode} but got pad ${pad}.`);\n    }\n    const convInfo = conv_util.computePool2DInfo($input.shape, filterSize, strides, dilations, pad, dimRoundingMode);\n    const res = ENGINE.runKernelFunc(backend => backend.maxPoolBackprop($dy, $input, $output, convInfo), { $dy, $input });\n    return res;\n}\n/**\n * Computes the backprop of an 2D avg pool.\n *\n * @param dy The dy error, of rank 4 or rank 3 of shape\n *     [batchSize, height, width, channels]. If rank 3, batch of 1 is\n * assumed.\n * @param input The input image, of rank 4 or rank 3 of shape\n *     [batchSize, height, width, channels]. If rank 3, batch of 1 is\n * assumed.\n * @param filterSize The filter size: `[filterHeight, filterWidth]`. If\n *     `filterSize` is a single number, then `filterHeight == filterWidth`.\n * @param strides The strides of the pooling: `[strideHeight, strideWidth]`. If\n *     `strides` is a single number, then `strideHeight == strideWidth`.\n * @param pad A string from: 'same', 'valid'. The type of padding algorithm\n *     used in the forward prop of the op.\n */\nfunction avgPoolBackprop(dy, input, filterSize, strides, dilations, pad) {\n    const $dy = convertToTensor(dy, 'dy', 'avgPoolBackprop');\n    const $input = convertToTensor(input, 'input', 'avgPoolBackprop');\n    util.assert($input.rank === $dy.rank, () => `Rank of input (${$input.rank}) does not match rank of dy (${$dy.rank})`);\n    if (dilations == null) {\n        dilations = [1, 1];\n    }\n    util.assert(conv_util.eitherStridesOrDilationsAreOne(strides, dilations), () => 'Error in avgPoolBackprop: Either strides or dilations must be 1. ' +\n        `Got strides ${strides} and dilations '${dilations}'`);\n    let input4D = $input;\n    let dy4D = $dy;\n    let reshapedTo4D = false;\n    if ($input.rank === 3) {\n        reshapedTo4D = true;\n        input4D = $input.as4D(1, $input.shape[0], $input.shape[1], $input.shape[2]);\n        dy4D = $dy.as4D(1, $dy.shape[0], $dy.shape[1], $dy.shape[2]);\n    }\n    util.assert(dy4D.rank === 4, () => `Error in avgPoolBackprop: dy must be rank 4 but got rank ` +\n        `${dy4D.rank}.`);\n    util.assert(input4D.rank === 4, () => `Error in avgPoolBackprop: input must be rank 4 but got rank ` +\n        `${input4D.rank}.`);\n    const convInfo = conv_util.computePool2DInfo(input4D.shape, filterSize, strides, dilations, pad);\n    const res = ENGINE.runKernelFunc(backend => backend.avgPoolBackprop(dy4D, input4D, convInfo), { dy4D, input4D });\n    if (reshapedTo4D) {\n        return res.as3D(res.shape[1], res.shape[2], res.shape[3]);\n    }\n    return res;\n}\n// Helper function to compute crops and paddings for pool with dilation > 1.\n// tslint:disable-next-line:max-line-length\n// https://github.com/tensorflow/tensorflow/blob/50f6bb67dc98c9b74630b6047aae7a4f8a40fd02/tensorflow/python/ops/array_ops.py#L2184\nfunction requiredSpaceToBatchPaddings(inputShape, blockShape, basePadding) {\n    const padStart = basePadding.map(b => b[0]);\n    const origPadEnd = basePadding.map(b => b[1]);\n    const fullInputShape = inputShape.concat(padStart, origPadEnd);\n    const padEndExtra = blockShape.map((b, i) => (b - fullInputShape[i] % b) % b);\n    const padEnd = origPadEnd.map((s, i) => s + padEndExtra[i]);\n    const paddings = blockShape.map((_, i) => [padStart[i], padEnd[i]]);\n    const crops = blockShape.map((_, i) => [0, padEndExtra[i]]);\n    return [paddings, crops];\n}\n// Helper function to compute base paddings for pool with dilation > 1.\n// tslint:disable-next-line:max-line-length\n// https://github.com/tensorflow/tensorflow/blob/50f6bb67dc98c9b74630b6047aae7a4f8a40fd02/tensorflow/python/ops/nn_ops.py#L524\nfunction withSpaceToBatchBasePaddings(filterShape, dilation) {\n    // Spatial dimensions of the filters and the upsampled filters in which we\n    // introduce (rate - 1) zeros between consecutive filter values.\n    const dilatedFilterShape = filterShape.map((s, i) => {\n        return s + (s - 1) * (dilation[i] - 1);\n    });\n    const padExtraShape = dilatedFilterShape.map(s => s - 1);\n    // When padding is odd, we pad more at end, following the same\n    // convention as conv2d.\n    const padExtraStart = padExtraShape.map(s => Math.floor(s / 2));\n    const padExtraEnd = padExtraShape.map((s, i) => s - padExtraStart[i]);\n    return padExtraShape.map((_, i) => {\n        return [padExtraStart[i], padExtraEnd[i]];\n    });\n}\n/**\n * Computes the 3D average pooling.\n *\n * ```js\n * const x = tf.tensor5d([1, 2, 3, 4, 5, 6, 7, 8], [1, 2, 2, 2, 1]);\n * const result = tf.avgPool3d(x, 2, 1, 'valid');\n * result.print();\n * ```\n *\n * @param x The input tensor, of rank 5 or rank 4 of shape\n *     `[batch, depth, height, width, inChannels]`.\n * @param filterSize The filter size:\n *     `[filterDepth, filterHeight, filterWidth]`.\n *     If `filterSize` is a single number,\n *     then `filterDepth == filterHeight == filterWidth`.\n * @param strides The strides of the pooling:\n *     `[strideDepth, strideHeight, strideWidth]`.\n *     If `strides` is a single number,\n *     then `strideDepth == strideHeight == strideWidth`.\n * @param pad The type of padding algorithm.\n *    - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *    - `valid`: output will be smaller than input if filter is larger\n *       than 1*1x1.\n *    - For more info, see this guide:\n *     [https://www.tensorflow.org/api_guides/python/nn#Convolution](\n *          https://www.tensorflow.org/api_guides/python/nn#Convolution)\n * @param dimRoundingMode The rounding mode used when computing output\n *     dimensions if pad is a number. If none is provided, it will not round\n *     and error if the output is of fractional size.\n * @param dataFormat An optional string from: \"NDHWC\", \"NCDHW\". Defaults to\n *     \"NDHWC\". Specify the data format of the input and output data. With the\n *     default format \"NDHWC\", the data is stored in the order of: [batch,\n *     depth, height, width, channels]. Only \"NDHWC\" is currently supported.\n * @param dilations The dilation rates:\n *     `[dilationDepth, dilationHeight, dilationWidth]`\n *     in which we sample input values across the depth, height and width\n *     dimensions in dilated pooling.\n *     Defaults to `[1, 1, 1]`. If `dilations` is a single number,\n *     then `dilationDepth == dilationHeight == dilationWidth`.\n *     If it is greater than 1, then all values of `strides` must be 1.\n */\n/** @doc {heading: 'Operations', subheading: 'Convolution'} */\nfunction avgPool3d_(x, filterSize, strides, pad, dimRoundingMode, dataFormat = 'NDHWC', dilations) {\n    const $x = convertToTensor(x, 'x', 'avgPool3d', 'float32');\n    let x5D = $x;\n    let reshapedTo5D = false;\n    if ($x.rank === 4) {\n        reshapedTo5D = true;\n        x5D = $x.as5D(1, $x.shape[0], $x.shape[1], $x.shape[2], $x.shape[3]);\n    }\n    if (dilations == null) {\n        dilations = [1, 1, 1];\n    }\n    util.assert(x5D.rank === 5, () => `Error in avgPool3d: x must be rank 5 but got rank ${x5D.rank}.`);\n    util.assert(dataFormat === 'NDHWC', () => `Error in avgPool3d: Only NDHWC is currently supported, ` +\n        `but got dataFormat of ${dataFormat}`);\n    util.assert(conv_util.eitherStridesOrDilationsAreOne(strides, dilations), () => 'Error in avgPool3d: Either strides or dilations must be 1. ' +\n        `Got strides ${strides} and dilations '${dilations}'`);\n    if (dimRoundingMode != null) {\n        util.assert(util.isInt(pad), () => `Error in avgPool3d: pad must be an integer when using, ` +\n            `dimRoundingMode ${dimRoundingMode} but got pad ${pad}.`);\n    }\n    const convInfo = conv_util.computePool3DInfo(x5D.shape, filterSize, strides, dilations, pad, dimRoundingMode, dataFormat);\n    const grad = (dy) => {\n        return {\n            x: () => avgPool3dBackprop(dy, x5D, filterSize, strides, dilations, pad, dimRoundingMode)\n        };\n    };\n    let res = ENGINE.runKernelFunc(backend => backend.avgPool3d(x5D, convInfo), { x: x5D }, grad);\n    res = res.cast(x5D.dtype);\n    if (reshapedTo5D) {\n        return res.as4D(res.shape[1], res.shape[2], res.shape[3], res.shape[4]);\n    }\n    return res;\n}\n/**\n * Computes the backprop of a 3d avg pool.\n *\n * @param dy The dy error, of rank 5 of shape\n *     [batchSize, depth, height, width, channels].\n * assumed.\n * @param input The original input image, of rank 5 or rank4 of shape\n *     [batchSize, depth, height, width, channels].\n * @param filterSize The filter size:\n *     `[filterDepth, filterHeight, filterWidth]`.\n *     `filterSize` is a single number,\n *     then `filterDepth == filterHeight == filterWidth`.\n * @param strides The strides of the pooling:\n *     `[strideDepth, strideHeight, strideWidth]`. If\n *     `strides` is a single number, then `strideHeight == strideWidth`.\n * @param dilations The dilation rates:\n *     `[dilationDepth, dilationHeight, dilationWidth]`\n *     in which we sample input values across the depth, height and width\n *     dimensions in dilated pooling.\n *     Defaults to `[1, 1, 1]`. If `dilations` is a single number,\n *     then `dilationDepth == dilationHeight == dilationWidth`.\n *     If it is greater than 1, then all values of `strides` must be 1.\n * @param pad A string from: 'same', 'valid'. The type of padding algorithm\n *     used in the forward prop of the op.\n * @param dimRoundingMode A string from: 'ceil', 'round', 'floor'. The\n *     rounding mode used when computing output dimensions if pad is a\n *     number. If none is provided, it will not round and error if the output\n *     is of fractional size.\n */\nfunction avgPool3dBackprop(dy, input, filterSize, strides, dilations, pad, dimRoundingMode) {\n    const $dy = convertToTensor(dy, 'dy', 'avgPool3dBackprop');\n    const $input = convertToTensor(input, 'input', 'avgPool3dBackprop');\n    let dy5D = $dy;\n    let input5D = $input;\n    let reshapedTo5D = false;\n    if ($input.rank === 4) {\n        reshapedTo5D = true;\n        dy5D = $dy.as5D(1, $dy.shape[0], $dy.shape[1], $dy.shape[2], $dy.shape[3]);\n        input5D = $input.as5D(1, $input.shape[0], $input.shape[1], $input.shape[2], $input.shape[3]);\n    }\n    util.assert(dy5D.rank === 5, () => `Error in avgPool3dBackprop: dy must be rank 5 but got rank ` +\n        `${dy5D.rank}.`);\n    util.assert(input5D.rank === 5, () => `Error in avgPool3dBackprop: input must be rank 5 but got rank ` +\n        `${input5D.rank}.`);\n    if (dilations == null) {\n        dilations = [1, 1, 1];\n    }\n    util.assert(conv_util.eitherStridesOrDilationsAreOne(strides, dilations), () => 'Error in avgPool3dBackprop: Either strides or dilations ' +\n        `must be 1. Got strides ${strides} and dilations '${dilations}'`);\n    if (dimRoundingMode != null) {\n        util.assert(util.isInt(pad), () => `Error in maxPool3dBackprop: pad must be an integer when ` +\n            `using, dimRoundingMode ${dimRoundingMode} but got pad ${pad}.`);\n    }\n    const convInfo = conv_util.computePool3DInfo(input5D.shape, filterSize, strides, dilations, pad, dimRoundingMode);\n    const res = ENGINE.runKernelFunc(backend => backend.avgPool3dBackprop(dy5D, input5D, convInfo), { dy5D, input5D });\n    if (reshapedTo5D) {\n        return res.as4D(res.shape[1], res.shape[2], res.shape[3], res.shape[4]);\n    }\n    return res;\n}\n/**\n * Computes the 3D max pooling.\n *\n * ```js\n * const x = tf.tensor5d([1, 2, 3, 4, 5, 6, 7, 8], [1, 2, 2, 2, 1]);\n * const result = tf.maxPool3d(x, 2, 1, 'valid');\n * result.print();\n * ```\n *\n * @param x The input tensor, of rank 5 or rank 4 of shape\n *     `[batch, depth, height, width, inChannels]`.\n * @param filterSize The filter size:\n *     `[filterDepth, filterHeight, filterWidth]`.\n *     If `filterSize` is a single number,\n *     then `filterDepth == filterHeight == filterWidth`.\n * @param strides The strides of the pooling:\n *     `[strideDepth, strideHeight, strideWidth]`.\n *     If `strides` is a single number,\n *     then `strideDepth == strideHeight == strideWidth`.\n * @param pad The type of padding algorithm.\n *    - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *    - `valid`: output will be smaller than input if filter is larger\n *       than 1*1x1.\n *    - For more info, see this guide:\n *     [https://www.tensorflow.org/api_guides/python/nn#Convolution](\n *          https://www.tensorflow.org/api_guides/python/nn#Convolution)\n * @param dimRoundingMode The rounding mode used when computing output\n *     dimensions if pad is a number. If none is provided, it will not round\n *     and error if the output is of fractional size.\n * @param dataFormat An optional string from: \"NDHWC\", \"NCDHW\". Defaults to\n *     \"NDHWC\". Specify the data format of the input and output data. With the\n *     default format \"NDHWC\", the data is stored in the order of: [batch,\n *     depth, height, width, channels]. Only \"NDHWC\" is currently supported.\n * @param dilations The dilation rates:\n *     `[dilationDepth, dilationHeight, dilationWidth]`\n *     in which we sample input values across the depth, height and width\n *     dimensions in dilated pooling.\n *     Defaults to `[1, 1, 1]`. If `dilations` is a single number,\n *     then `dilationDepth == dilationHeight == dilationWidth`.\n *     If it is greater than 1, then all values of `strides` must be 1.\n */\n/** @doc {heading: 'Operations', subheading: 'Convolution'} */\nfunction maxPool3d_(x, filterSize, strides, pad, dimRoundingMode, dataFormat = 'NDHWC', dilations) {\n    const $x = convertToTensor(x, 'x', 'maxPool3d');\n    let x5D = $x;\n    let reshapedTo5D = false;\n    if ($x.rank === 4) {\n        reshapedTo5D = true;\n        x5D = $x.as5D(1, $x.shape[0], $x.shape[1], $x.shape[2], $x.shape[3]);\n    }\n    if (dilations == null) {\n        dilations = [1, 1, 1];\n    }\n    util.assert(x5D.rank === 5, () => `Error in maxPool3d: x must be rank 5 but got rank ${x5D.rank}.`);\n    util.assert(dataFormat === 'NDHWC', () => `Error in maxPool3d: Only NDHWC is currently supported, ` +\n        `but got dataFormat of ${dataFormat}`);\n    util.assert(conv_util.eitherStridesOrDilationsAreOne(strides, dilations), () => 'Error in maxPool3d: Either strides or dilations must be 1. ' +\n        `Got strides ${strides} and dilations '${dilations}'`);\n    if (dimRoundingMode != null) {\n        util.assert(util.isInt(pad), () => `Error in maxPool3d: pad must be an integer when using, ` +\n            `dimRoundingMode ${dimRoundingMode} but got pad ${pad}.`);\n    }\n    const convInfo = conv_util.computePool3DInfo(x5D.shape, filterSize, strides, dilations, pad, dimRoundingMode, dataFormat);\n    const grad = (dy, saved) => {\n        const [x5D, y] = saved;\n        return {\n            x: () => maxPool3dBackprop(dy, x5D, y, filterSize, strides, dilations, pad, dimRoundingMode)\n        };\n    };\n    const res = ENGINE.runKernelFunc((backend, save) => {\n        const y = backend.maxPool3d(x5D, convInfo);\n        save([x5D, y]);\n        return y;\n    }, { x: x5D }, grad);\n    if (reshapedTo5D) {\n        return res.as4D(res.shape[1], res.shape[2], res.shape[3], res.shape[4]);\n    }\n    return res;\n}\n/**\n * Computes the backprop of a 3d max pool.\n *\n * @param dy The dy error, of rank 5 of shape\n *     [batchSize, depth, height, width, channels].\n * assumed.\n * @param input The original input image, of rank 5 or rank 4 of shape\n *     [batchSize, depth, height, width, channels].\n * @param output The original output image, of rank 5 of shape\n *     [batchSize, outDepth, outHeight, outWidth, channels].\n * @param filterSize The filter size:\n *     `[filterDepth, filterHeight, filterWidth]`.\n *     `filterSize` is a single number,\n *     then `filterDepth == filterHeight == filterWidth`.\n * @param strides The strides of the pooling:\n *     `[strideDepth, strideHeight, strideWidth]`. If\n *     `strides` is a single number, then `strideHeight == strideWidth`.\n * @param dilations The dilation rates:\n *     `[dilationDepth, dilationHeight, dilationWidth]`\n *     in which we sample input values across the depth, height and width\n *     dimensions in dilated pooling.\n *     Defaults to `[1, 1, 1]`. If `dilations` is a single number,\n *     then `dilationDepth == dilationHeight == dilationWidth`.\n *     If it is greater than 1, then all values of `strides` must be 1.\n * @param pad A string from: 'same', 'valid'. The type of padding algorithm\n *     used in the forward prop of the op.\n * @param dimRoundingMode A string from: 'ceil', 'round', 'floor'. The\n *     rounding mode used when computing output dimensions if pad is a\n *     number. If none is provided, it will not round and error if the output\n *     is of fractional size.\n */\nfunction maxPool3dBackprop(dy, input, output, filterSize, strides, dilations, pad, dimRoundingMode) {\n    const $dy = convertToTensor(dy, 'dy', 'maxPool3dBackprop');\n    const $input = convertToTensor(input, 'input', 'maxPool3dBackprop');\n    const $output = convertToTensor(output, 'output', 'maxPool3dBackprop');\n    let dy5D = $dy;\n    let input5D = $input;\n    let output5D = $output;\n    let reshapedTo5D = false;\n    if ($input.rank === 4) {\n        reshapedTo5D = true;\n        dy5D = $dy.as5D(1, $dy.shape[0], $dy.shape[1], $dy.shape[2], $dy.shape[3]);\n        input5D = $input.as5D(1, $input.shape[0], $input.shape[1], $input.shape[2], $input.shape[3]);\n        output5D = $output.as5D(1, $output.shape[0], $output.shape[1], $output.shape[2], $output.shape[3]);\n    }\n    util.assert(dy5D.rank === 5, () => `Error in maxPool3dBackprop: dy must be rank 5 but got rank ` +\n        `${dy5D.rank}.`);\n    util.assert(input5D.rank === 5, () => `Error in maxPool3dBackprop: input must be rank 5 but got rank ` +\n        `${input5D.rank}.`);\n    util.assert(output5D.rank === 5, () => `Error in maxPool3dBackprop: output must be rank 5 but got rank ` +\n        `${output5D.rank}.`);\n    if (dilations == null) {\n        dilations = [1, 1, 1];\n    }\n    util.assert(conv_util.eitherStridesOrDilationsAreOne(strides, dilations), () => 'Error in maxPool3dBackprop: Either strides or dilations ' +\n        `must be 1. Got strides ${strides} and dilations '${dilations}'`);\n    if (dimRoundingMode != null) {\n        util.assert(util.isInt(pad), () => `Error in maxPool3dBackprop: pad must be an integer when ` +\n            `using, dimRoundingMode ${dimRoundingMode} but got pad ${pad}.`);\n    }\n    const convInfo = conv_util.computePool3DInfo(input5D.shape, filterSize, strides, dilations, pad, dimRoundingMode);\n    const res = ENGINE.runKernelFunc(backend => backend.maxPool3dBackprop(dy5D, input5D, output5D, convInfo), { dy5D, input5D });\n    if (reshapedTo5D) {\n        return res.as4D(res.shape[1], res.shape[2], res.shape[3], res.shape[4]);\n    }\n    return res;\n}\n/**\n * Computes the 2D max pooling of an image with Argmax index.\n * The indices in argmax are flattened, so that a maximum value at position `[b,\n * y, x, c]` becomes flattened index: `(y * width + x) * channels + c` if\n * include_batch_in_index is False; `((b * height + y) * width + x) * channels\n * +c` if include_batch_in_index is True.\n *\n * The indices returned are always in `[0, height) x [0, width)` before\n * flattening.\n *\n * @param x The input tensor, of rank 4 or rank 3 of shape\n *     `[batch, height, width, inChannels]`. If rank 3, batch of 1 is assumed.\n * @param filterSize The filter size: `[filterHeight, filterWidth]`. If\n *     `filterSize` is a single number, then `filterHeight == filterWidth`.\n * @param strides The strides of the pooling: `[strideHeight, strideWidth]`. If\n *     `strides` is a single number, then `strideHeight == strideWidth`.\n * @param dataFormat An optional string from: \"NDHWC\", \"NCDHW\". Defaults to\n *     \"NDHWC\". Specify the data format of the input and output data. With the\n *     default format \"NDHWC\", the data is stored in the order of: [batch,\n *     depth, height, width, channels]. Only \"NDHWC\" is currently supported.\n * @param pad The type of padding algorithm.\n *    - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *    - `valid`: output will be smaller than input if filter is larger\n *       than 1x1.\n *    - For more info, see this guide:\n *     [https://www.tensorflow.org/api_guides/python/nn#Convolution](\n *          https://www.tensorflow.org/api_guides/python/nn#Convolution)\n * @param includeBatchIndex Defaults to False. Whether to include batch\n *    dimension in flattened index of argmax.\n */\n/** @doc {heading: 'Operations', subheading: 'Convolution'} */\n/** @doc {heading: 'Operations', subheading: 'Convolution'} */\nfunction maxPoolWithArgmax_(x, filterSize, strides, pad, includeBatchInIndex = false) {\n    const $x = convertToTensor(x, 'x', 'maxPoolWithArgmax');\n    const attrs = { filterSize, strides, pad, includeBatchInIndex };\n    const result = ENGINE.runKernel('MaxPoolWithArgmax', { x: $x }, attrs);\n    return { result: result[0], indexes: result[1] };\n}\nexport const maxPool = op({ maxPool_ });\nexport const avgPool = op({ avgPool_ });\nexport const pool = op({ pool_ });\nexport const maxPool3d = op({ maxPool3d_ });\nexport const avgPool3d = op({ avgPool3d_ });\nexport const maxPoolWithArgmax = op({ maxPoolWithArgmax_ });\n//# sourceMappingURL=pool.js.map"]},"metadata":{},"sourceType":"module"}