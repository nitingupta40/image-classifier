{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { scalar } from '@tensorflow/tfjs-core';\nimport { TensorArray } from '../../executor/tensor_array';\nimport { getParamValue, getTensor } from './utils';\nexport const executeOp = async (node, tensorMap, context) => {\n  switch (node.op) {\n    case 'LoopCond':\n      return [getParamValue('pred', node, tensorMap, context).clone()];\n\n    case 'Switch':\n      {\n        const pred = getParamValue('pred', node, tensorMap, context);\n        const data = getParamValue('data', node, tensorMap, context); // Outputs nodes :0 => false, :1 => true\n\n        return (await pred.data())[0] ? [undefined, data.clone()] : [data.clone(), undefined];\n      }\n\n    case 'Merge':\n      const inputName = node.inputNames.find(name => getTensor(name, tensorMap, context) !== undefined);\n      return inputName ? [getTensor(inputName, tensorMap, context).clone()] : undefined;\n\n    case 'Enter':\n      const frameId = getParamValue('frameName', node, tensorMap, context);\n      const data = getParamValue('tensor', node, tensorMap, context);\n      context.enterFrame(frameId);\n      return [data.clone()];\n\n    case 'Exit':\n      const tensor = getParamValue('tensor', node, tensorMap, context);\n      context.exitFrame();\n      return [tensor.clone()];\n\n    case 'NextIteration':\n      const input = getParamValue('tensor', node, tensorMap, context);\n      context.nextIteration();\n      return [input.clone()];\n\n    case 'TensorArrayV3':\n      const size = getParamValue('size', node, tensorMap, context);\n      const dtype = getParamValue('dtype', node, tensorMap, context);\n      const elementShape = getParamValue('elementShape', node, tensorMap, context);\n      const dynamicSize = getParamValue('dynamicSize', node, tensorMap, context);\n      const clearAfterRead = getParamValue('clearAfterRead', node, tensorMap, context);\n      const identicalElementShapes = getParamValue('identicalElementShapes', node, tensorMap, context);\n      const name = getParamValue('name', node, tensorMap, context);\n      const tensorArray = new TensorArray(name, dtype, size, elementShape, identicalElementShapes, dynamicSize, clearAfterRead);\n      context.addTensorArray(tensorArray);\n      return [scalar(tensorArray.id), scalar(1.0)];\n\n    case 'TensorArrayWriteV3':\n      const id = getParamValue('tensorArrayId', node, tensorMap, context);\n      const index = getParamValue('index', node, tensorMap, context);\n      const writeTensor = getParamValue('tensor', node, tensorMap, context);\n      const writeTensorArray = context.getTensorArray(id);\n      writeTensorArray.write(index, writeTensor);\n      return [scalar(1.0)];\n\n    case 'TensorArrayReadV3':\n      const readId = getParamValue('tensorArrayId', node, tensorMap, context);\n      const readIndex = getParamValue('index', node, tensorMap, context);\n      const readTensorArray = context.getTensorArray(readId);\n      return [readTensorArray.read(readIndex)];\n\n    case 'TensorArrayGatherV3':\n      const gatherId = getParamValue('tensorArrayId', node, tensorMap, context);\n      const gatherIndices = getParamValue('indices', node, tensorMap, context);\n      const gatherDtype = getParamValue('dtype', node, tensorMap, context);\n      const gatherTensorArray = context.getTensorArray(gatherId);\n      return [gatherTensorArray.gather(gatherIndices, gatherDtype)];\n\n    case 'TensorArrayScatterV3':\n      const scatterId = getParamValue('tensorArrayId', node, tensorMap, context);\n      const scatterIndices = getParamValue('indices', node, tensorMap, context);\n      const scatterTensor = getParamValue('tensor', node, tensorMap, context);\n      const scatterTensorArray = context.getTensorArray(scatterId);\n      scatterTensorArray.scatter(scatterIndices, scatterTensor);\n      return [scalar(1.0)];\n\n    case 'TensorArrayConcatV3':\n      const concatId = getParamValue('tensorArrayId', node, tensorMap, context);\n      const concatTensorArray = context.getTensorArray(concatId);\n      const concatDtype = getParamValue('dtype', node, tensorMap, context);\n      return [concatTensorArray.concat(concatDtype)];\n\n    case 'TensorArraySplitV3':\n      const splitId = getParamValue('tensorArrayId', node, tensorMap, context);\n      const splitTensor = getParamValue('tensor', node, tensorMap, context);\n      const lengths = getParamValue('lengths', node, tensorMap, context);\n      const splitTensorArray = context.getTensorArray(splitId);\n      splitTensorArray.split(lengths, splitTensor);\n      return [scalar(1.0)];\n\n    case 'TensorArraySizeV3':\n      const sizeId = getParamValue('tensorArrayId', node, tensorMap, context);\n      const sizeTensorArray = context.getTensorArray(sizeId);\n      return [scalar(sizeTensorArray.size(), 'int32')];\n\n    case 'TensorArrayCloseV3':\n      const closeId = getParamValue('tensorArrayId', node, tensorMap, context);\n      const closeTensorArray = context.getTensorArray(closeId);\n      closeTensorArray.clearAndClose();\n      return [scalar(0)];\n\n    default:\n      throw TypeError(`Node type ${node.op} is not implemented`);\n  }\n};\nexport const CATEGORY = 'control';","map":{"version":3,"sources":["../../../src/operations/executors/control_executor.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;AAkBA,SAAQ,MAAR,QAAqB,uBAArB;AAIA,SAAQ,WAAR,QAA0B,6BAA1B;AAGA,SAAQ,aAAR,EAAuB,SAAvB,QAAuC,SAAvC;AAEA,OAAO,MAAM,SAAS,GAA4B,OAC9C,IAD8C,EAClC,SADkC,EAE9C,OAF8C,KAEM;AACtD,UAAQ,IAAI,CAAC,EAAb;AACE,SAAK,UAAL;AACE,aAAO,CACJ,aAAa,CAAC,MAAD,EAAS,IAAT,EAAe,SAAf,EAA0B,OAA1B,CAAb,CAA+D,KAA/D,EADI,CAAP;;AAGF,SAAK,QAAL;AAAe;AACb,cAAM,IAAI,GACN,aAAa,CAAC,MAAD,EAAS,IAAT,EAAe,SAAf,EAA0B,OAA1B,CADjB;AAEA,cAAM,IAAI,GACN,aAAa,CAAC,MAAD,EAAS,IAAT,EAAe,SAAf,EAA0B,OAA1B,CADjB,CAHa,CAKb;;AACA,eAAO,CAAC,MAAM,IAAI,CAAC,IAAL,EAAP,EAAoB,CAApB,IAAyB,CAAC,SAAD,EAAY,IAAI,CAAC,KAAL,EAAZ,CAAzB,GACyB,CAAC,IAAI,CAAC,KAAL,EAAD,EAAe,SAAf,CADhC;AAED;;AACD,SAAK,OAAL;AACE,YAAM,SAAS,GAAG,IAAI,CAAC,UAAL,CAAgB,IAAhB,CACd,IAAI,IAAI,SAAS,CAAC,IAAD,EAAO,SAAP,EAAkB,OAAlB,CAAT,KAAwC,SADlC,CAAlB;AAEA,aAAO,SAAS,GAAG,CAAC,SAAS,CAAC,SAAD,EAAY,SAAZ,EAAuB,OAAvB,CAAT,CAAyC,KAAzC,EAAD,CAAH,GACG,SADnB;;AAGF,SAAK,OAAL;AACE,YAAM,OAAO,GACT,aAAa,CAAC,WAAD,EAAc,IAAd,EAAoB,SAApB,EAA+B,OAA/B,CADjB;AAEA,YAAM,IAAI,GACN,aAAa,CAAC,QAAD,EAAW,IAAX,EAAiB,SAAjB,EAA4B,OAA5B,CADjB;AAEA,MAAA,OAAO,CAAC,UAAR,CAAmB,OAAnB;AACA,aAAO,CAAC,IAAI,CAAC,KAAL,EAAD,CAAP;;AAEF,SAAK,MAAL;AACE,YAAM,MAAM,GACR,aAAa,CAAC,QAAD,EAAW,IAAX,EAAiB,SAAjB,EAA4B,OAA5B,CADjB;AAEA,MAAA,OAAO,CAAC,SAAR;AACA,aAAO,CAAC,MAAM,CAAC,KAAP,EAAD,CAAP;;AAEF,SAAK,eAAL;AACE,YAAM,KAAK,GACP,aAAa,CAAC,QAAD,EAAW,IAAX,EAAiB,SAAjB,EAA4B,OAA5B,CADjB;AAEA,MAAA,OAAO,CAAC,aAAR;AACA,aAAO,CAAC,KAAK,CAAC,KAAN,EAAD,CAAP;;AAEF,SAAK,eAAL;AACE,YAAM,IAAI,GAAG,aAAa,CAAC,MAAD,EAAS,IAAT,EAAe,SAAf,EAA0B,OAA1B,CAA1B;AACA,YAAM,KAAK,GACP,aAAa,CAAC,OAAD,EAAU,IAAV,EAAgB,SAAhB,EAA2B,OAA3B,CADjB;AAEA,YAAM,YAAY,GACd,aAAa,CAAC,cAAD,EAAiB,IAAjB,EAAuB,SAAvB,EAAkC,OAAlC,CADjB;AAEA,YAAM,WAAW,GACb,aAAa,CAAC,aAAD,EAAgB,IAAhB,EAAsB,SAAtB,EAAiC,OAAjC,CADjB;AAEA,YAAM,cAAc,GAChB,aAAa,CAAC,gBAAD,EAAmB,IAAnB,EAAyB,SAAzB,EAAoC,OAApC,CADjB;AAEA,YAAM,sBAAsB,GACxB,aAAa,CAAC,wBAAD,EAA2B,IAA3B,EAAiC,SAAjC,EAA4C,OAA5C,CADjB;AAGA,YAAM,IAAI,GAAG,aAAa,CAAC,MAAD,EAAS,IAAT,EAAe,SAAf,EAA0B,OAA1B,CAA1B;AACA,YAAM,WAAW,GAAG,IAAI,WAAJ,CAChB,IADgB,EACV,KADU,EACH,IADG,EACG,YADH,EACiB,sBADjB,EACyC,WADzC,EAEhB,cAFgB,CAApB;AAGA,MAAA,OAAO,CAAC,cAAR,CAAuB,WAAvB;AACA,aAAO,CAAC,MAAM,CAAC,WAAW,CAAC,EAAb,CAAP,EAAyB,MAAM,CAAC,GAAD,CAA/B,CAAP;;AAEF,SAAK,oBAAL;AACE,YAAM,EAAE,GACJ,aAAa,CAAC,eAAD,EAAkB,IAAlB,EAAwB,SAAxB,EAAmC,OAAnC,CADjB;AAEA,YAAM,KAAK,GAAG,aAAa,CAAC,OAAD,EAAU,IAAV,EAAgB,SAAhB,EAA2B,OAA3B,CAA3B;AACA,YAAM,WAAW,GACb,aAAa,CAAC,QAAD,EAAW,IAAX,EAAiB,SAAjB,EAA4B,OAA5B,CADjB;AAEA,YAAM,gBAAgB,GAAG,OAAO,CAAC,cAAR,CAAuB,EAAvB,CAAzB;AACA,MAAA,gBAAgB,CAAC,KAAjB,CAAuB,KAAvB,EAA8B,WAA9B;AACA,aAAO,CAAC,MAAM,CAAC,GAAD,CAAP,CAAP;;AAEF,SAAK,mBAAL;AACE,YAAM,MAAM,GACR,aAAa,CAAC,eAAD,EAAkB,IAAlB,EAAwB,SAAxB,EAAmC,OAAnC,CADjB;AAEA,YAAM,SAAS,GACX,aAAa,CAAC,OAAD,EAAU,IAAV,EAAgB,SAAhB,EAA2B,OAA3B,CADjB;AAEA,YAAM,eAAe,GAAG,OAAO,CAAC,cAAR,CAAuB,MAAvB,CAAxB;AACA,aAAO,CAAC,eAAe,CAAC,IAAhB,CAAqB,SAArB,CAAD,CAAP;;AAEF,SAAK,qBAAL;AACE,YAAM,QAAQ,GACV,aAAa,CAAC,eAAD,EAAkB,IAAlB,EAAwB,SAAxB,EAAmC,OAAnC,CADjB;AAEA,YAAM,aAAa,GACf,aAAa,CAAC,SAAD,EAAY,IAAZ,EAAkB,SAAlB,EAA6B,OAA7B,CADjB;AAEA,YAAM,WAAW,GACb,aAAa,CAAC,OAAD,EAAU,IAAV,EAAgB,SAAhB,EAA2B,OAA3B,CADjB;AAEA,YAAM,iBAAiB,GAAG,OAAO,CAAC,cAAR,CAAuB,QAAvB,CAA1B;AACA,aAAO,CAAC,iBAAiB,CAAC,MAAlB,CAAyB,aAAzB,EAAwC,WAAxC,CAAD,CAAP;;AAEF,SAAK,sBAAL;AACE,YAAM,SAAS,GACX,aAAa,CAAC,eAAD,EAAkB,IAAlB,EAAwB,SAAxB,EAAmC,OAAnC,CADjB;AAEA,YAAM,cAAc,GAChB,aAAa,CAAC,SAAD,EAAY,IAAZ,EAAkB,SAAlB,EAA6B,OAA7B,CADjB;AAEA,YAAM,aAAa,GACf,aAAa,CAAC,QAAD,EAAW,IAAX,EAAiB,SAAjB,EAA4B,OAA5B,CADjB;AAEA,YAAM,kBAAkB,GAAG,OAAO,CAAC,cAAR,CAAuB,SAAvB,CAA3B;AACA,MAAA,kBAAkB,CAAC,OAAnB,CAA2B,cAA3B,EAA2C,aAA3C;AACA,aAAO,CAAC,MAAM,CAAC,GAAD,CAAP,CAAP;;AAEF,SAAK,qBAAL;AACE,YAAM,QAAQ,GACV,aAAa,CAAC,eAAD,EAAkB,IAAlB,EAAwB,SAAxB,EAAmC,OAAnC,CADjB;AAEA,YAAM,iBAAiB,GAAG,OAAO,CAAC,cAAR,CAAuB,QAAvB,CAA1B;AACA,YAAM,WAAW,GACb,aAAa,CAAC,OAAD,EAAU,IAAV,EAAgB,SAAhB,EAA2B,OAA3B,CADjB;AAEA,aAAO,CAAC,iBAAiB,CAAC,MAAlB,CAAyB,WAAzB,CAAD,CAAP;;AAEF,SAAK,oBAAL;AACE,YAAM,OAAO,GACT,aAAa,CAAC,eAAD,EAAkB,IAAlB,EAAwB,SAAxB,EAAmC,OAAnC,CADjB;AAEA,YAAM,WAAW,GACb,aAAa,CAAC,QAAD,EAAW,IAAX,EAAiB,SAAjB,EAA4B,OAA5B,CADjB;AAEA,YAAM,OAAO,GACT,aAAa,CAAC,SAAD,EAAY,IAAZ,EAAkB,SAAlB,EAA6B,OAA7B,CADjB;AAEA,YAAM,gBAAgB,GAAG,OAAO,CAAC,cAAR,CAAuB,OAAvB,CAAzB;AACA,MAAA,gBAAgB,CAAC,KAAjB,CAAuB,OAAvB,EAAgC,WAAhC;AACA,aAAO,CAAC,MAAM,CAAC,GAAD,CAAP,CAAP;;AAEF,SAAK,mBAAL;AACE,YAAM,MAAM,GACR,aAAa,CAAC,eAAD,EAAkB,IAAlB,EAAwB,SAAxB,EAAmC,OAAnC,CADjB;AAEA,YAAM,eAAe,GAAG,OAAO,CAAC,cAAR,CAAuB,MAAvB,CAAxB;AACA,aAAO,CAAC,MAAM,CAAC,eAAe,CAAC,IAAhB,EAAD,EAAyB,OAAzB,CAAP,CAAP;;AAEF,SAAK,oBAAL;AACE,YAAM,OAAO,GACT,aAAa,CAAC,eAAD,EAAkB,IAAlB,EAAwB,SAAxB,EAAmC,OAAnC,CADjB;AAEA,YAAM,gBAAgB,GAAG,OAAO,CAAC,cAAR,CAAuB,OAAvB,CAAzB;AACA,MAAA,gBAAgB,CAAC,aAAjB;AACA,aAAO,CAAC,MAAM,CAAC,CAAD,CAAP,CAAP;;AACF;AACE,YAAM,SAAS,CAAC,aAAa,IAAI,CAAC,EAAE,qBAArB,CAAf;AAnIJ;AAqID,CAxIM;AA0IP,OAAO,MAAM,QAAQ,GAAG,SAAjB","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { scalar } from '@tensorflow/tfjs-core';\nimport { TensorArray } from '../../executor/tensor_array';\nimport { getParamValue, getTensor } from './utils';\nexport const executeOp = async (node, tensorMap, context) => {\n    switch (node.op) {\n        case 'LoopCond':\n            return [\n                getParamValue('pred', node, tensorMap, context).clone()\n            ];\n        case 'Switch': {\n            const pred = getParamValue('pred', node, tensorMap, context);\n            const data = getParamValue('data', node, tensorMap, context);\n            // Outputs nodes :0 => false, :1 => true\n            return (await pred.data())[0] ? [undefined, data.clone()] :\n                [data.clone(), undefined];\n        }\n        case 'Merge':\n            const inputName = node.inputNames.find(name => getTensor(name, tensorMap, context) !== undefined);\n            return inputName ? [getTensor(inputName, tensorMap, context).clone()] :\n                undefined;\n        case 'Enter':\n            const frameId = getParamValue('frameName', node, tensorMap, context);\n            const data = getParamValue('tensor', node, tensorMap, context);\n            context.enterFrame(frameId);\n            return [data.clone()];\n        case 'Exit':\n            const tensor = getParamValue('tensor', node, tensorMap, context);\n            context.exitFrame();\n            return [tensor.clone()];\n        case 'NextIteration':\n            const input = getParamValue('tensor', node, tensorMap, context);\n            context.nextIteration();\n            return [input.clone()];\n        case 'TensorArrayV3':\n            const size = getParamValue('size', node, tensorMap, context);\n            const dtype = getParamValue('dtype', node, tensorMap, context);\n            const elementShape = getParamValue('elementShape', node, tensorMap, context);\n            const dynamicSize = getParamValue('dynamicSize', node, tensorMap, context);\n            const clearAfterRead = getParamValue('clearAfterRead', node, tensorMap, context);\n            const identicalElementShapes = getParamValue('identicalElementShapes', node, tensorMap, context);\n            const name = getParamValue('name', node, tensorMap, context);\n            const tensorArray = new TensorArray(name, dtype, size, elementShape, identicalElementShapes, dynamicSize, clearAfterRead);\n            context.addTensorArray(tensorArray);\n            return [scalar(tensorArray.id), scalar(1.0)];\n        case 'TensorArrayWriteV3':\n            const id = getParamValue('tensorArrayId', node, tensorMap, context);\n            const index = getParamValue('index', node, tensorMap, context);\n            const writeTensor = getParamValue('tensor', node, tensorMap, context);\n            const writeTensorArray = context.getTensorArray(id);\n            writeTensorArray.write(index, writeTensor);\n            return [scalar(1.0)];\n        case 'TensorArrayReadV3':\n            const readId = getParamValue('tensorArrayId', node, tensorMap, context);\n            const readIndex = getParamValue('index', node, tensorMap, context);\n            const readTensorArray = context.getTensorArray(readId);\n            return [readTensorArray.read(readIndex)];\n        case 'TensorArrayGatherV3':\n            const gatherId = getParamValue('tensorArrayId', node, tensorMap, context);\n            const gatherIndices = getParamValue('indices', node, tensorMap, context);\n            const gatherDtype = getParamValue('dtype', node, tensorMap, context);\n            const gatherTensorArray = context.getTensorArray(gatherId);\n            return [gatherTensorArray.gather(gatherIndices, gatherDtype)];\n        case 'TensorArrayScatterV3':\n            const scatterId = getParamValue('tensorArrayId', node, tensorMap, context);\n            const scatterIndices = getParamValue('indices', node, tensorMap, context);\n            const scatterTensor = getParamValue('tensor', node, tensorMap, context);\n            const scatterTensorArray = context.getTensorArray(scatterId);\n            scatterTensorArray.scatter(scatterIndices, scatterTensor);\n            return [scalar(1.0)];\n        case 'TensorArrayConcatV3':\n            const concatId = getParamValue('tensorArrayId', node, tensorMap, context);\n            const concatTensorArray = context.getTensorArray(concatId);\n            const concatDtype = getParamValue('dtype', node, tensorMap, context);\n            return [concatTensorArray.concat(concatDtype)];\n        case 'TensorArraySplitV3':\n            const splitId = getParamValue('tensorArrayId', node, tensorMap, context);\n            const splitTensor = getParamValue('tensor', node, tensorMap, context);\n            const lengths = getParamValue('lengths', node, tensorMap, context);\n            const splitTensorArray = context.getTensorArray(splitId);\n            splitTensorArray.split(lengths, splitTensor);\n            return [scalar(1.0)];\n        case 'TensorArraySizeV3':\n            const sizeId = getParamValue('tensorArrayId', node, tensorMap, context);\n            const sizeTensorArray = context.getTensorArray(sizeId);\n            return [scalar(sizeTensorArray.size(), 'int32')];\n        case 'TensorArrayCloseV3':\n            const closeId = getParamValue('tensorArrayId', node, tensorMap, context);\n            const closeTensorArray = context.getTensorArray(closeId);\n            closeTensorArray.clearAndClose();\n            return [scalar(0)];\n        default:\n            throw TypeError(`Node type ${node.op} is not implemented`);\n    }\n};\nexport const CATEGORY = 'control';\n//# sourceMappingURL=control_executor.js.map"]},"metadata":{},"sourceType":"module"}