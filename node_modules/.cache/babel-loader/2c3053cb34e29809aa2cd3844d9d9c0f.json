{"ast":null,"code":"/**\n * @license\n * Copyright 2017 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport * as util from '../util';\nexport function assertParamsValid(input, begin, size) {\n  util.assert(input.rank === begin.length, () => `Error in slice${input.rank}D: Length of begin ${begin} must ` + `match the rank of the array (${input.rank}).`);\n  util.assert(input.rank === size.length, () => `Error in slice${input.rank}D: Length of size ${size} must ` + `match the rank of the array (${input.rank}).`);\n\n  for (let i = 0; i < input.rank; ++i) {\n    util.assert(begin[i] + size[i] <= input.shape[i], () => `Error in slice${input.rank}D: begin[${i}] + size[${i}] ` + `(${begin[i] + size[i]}) would overflow input.shape[${i}] (${input.shape[i]})`);\n  }\n}\n/** Converts a binary mask to an array of axes. Used in stridedSlice(). */\n\nexport function maskToAxes(mask) {\n  const axes = [];\n  let axis = 0;\n\n  while (mask > 0) {\n    if (mask & 1) {\n      axes.push(axis);\n    }\n\n    mask /= 2;\n    axis++;\n  }\n\n  return axes;\n}\n/** Computes the output shape given the strided slice params. */\n\nexport function computeOutShape(begin, end, strides) {\n  const size = [];\n\n  for (let axis = 0; axis < begin.length; axis++) {\n    size[axis] = Math.ceil((end[axis] - begin[axis]) / strides[axis]);\n  }\n\n  return size;\n}\nexport function startForAxis(beginMask, startIndices, strides, inputShape, axis) {\n  // Begin with the specified index\n  let start = startIndices[axis];\n  const stride = strides[axis] || 1; // Check the axis bit from right of beginMask or the begin index is not set\n  // for the axis.\n\n  if (beginMask & 1 << axis || start == null) {\n    if (stride > 0) {\n      // Forward iteration - use the first element. These values will get\n      // clamped below (Note: We could have set them to 0 and axis_size-1, but\n      // use lowest() and max() to maintain symmetry with StopForAxis())\n      start = Number.MIN_SAFE_INTEGER;\n    } else {\n      // Backward iteration - use the last element.\n      start = Number.MAX_SAFE_INTEGER;\n    }\n  } // Handle negative indices\n\n\n  const axisSize = inputShape[axis];\n\n  if (start < 0) {\n    start += axisSize;\n  } // Clamping\n\n\n  start = util.clamp(0, start, axisSize - 1);\n  return start;\n}\nexport function stopForAxis(endMask, stopIndices, strides, inputShape, axis) {\n  // Begin with the specified index\n  let stop = stopIndices[axis];\n  const stride = strides[axis] || 1; // Check the axis bit from right of endMask or if the stop index is not set\n  // for this axis.\n\n  if (endMask & 1 << axis || stop == null) {\n    if (stride > 0) {\n      // Forward iteration - use the last element. These values will get\n      // clamped below\n      stop = Number.MAX_SAFE_INTEGER;\n    } else {\n      // Backward iteration - use the first element.\n      stop = Number.MIN_SAFE_INTEGER;\n    }\n  } // Handle negative indices\n\n\n  const axisSize = inputShape[axis];\n\n  if (stop < 0) {\n    stop += axisSize;\n  } // Clamping\n  // Because the end index points one past the last element, we need slightly\n  // different clamping ranges depending on the direction.\n\n\n  if (stride > 0) {\n    // Forward iteration\n    stop = util.clamp(0, stop, axisSize);\n  } else {\n    // Backward iteration\n    stop = util.clamp(-1, stop, axisSize - 1);\n  }\n\n  return stop;\n}\n/**\n * Returns true if the slice occupies a continous set of elements in the\n * 'flat' space.\n */\n\nexport function isSliceContinous(shape, begin, size) {\n  // Index of the first axis that has size > 1.\n  let firstNonOneAxis = size.length;\n\n  for (let i = 0; i < size.length; i++) {\n    if (size[i] > 1) {\n      firstNonOneAxis = i;\n      break;\n    }\n  }\n\n  for (let i = firstNonOneAxis + 1; i < size.length; i++) {\n    if (begin[i] > 0 || size[i] !== shape[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\nexport function computeFlatOffset(begin, strides) {\n  let flatOffset = begin.length > 0 ? begin[begin.length - 1] : 1;\n\n  for (let i = 0; i < begin.length - 1; i++) {\n    flatOffset += begin[i] * strides[i];\n  }\n\n  return flatOffset;\n}","map":{"version":3,"sources":["../../src/ops/slice_util.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2017 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport * as util from '../util';\nexport function assertParamsValid(input, begin, size) {\n    util.assert(input.rank === begin.length, () => `Error in slice${input.rank}D: Length of begin ${begin} must ` +\n        `match the rank of the array (${input.rank}).`);\n    util.assert(input.rank === size.length, () => `Error in slice${input.rank}D: Length of size ${size} must ` +\n        `match the rank of the array (${input.rank}).`);\n    for (let i = 0; i < input.rank; ++i) {\n        util.assert(begin[i] + size[i] <= input.shape[i], () => `Error in slice${input.rank}D: begin[${i}] + size[${i}] ` +\n            `(${begin[i] + size[i]}) would overflow input.shape[${i}] (${input.shape[i]})`);\n    }\n}\n/** Converts a binary mask to an array of axes. Used in stridedSlice(). */\nexport function maskToAxes(mask) {\n    const axes = [];\n    let axis = 0;\n    while (mask > 0) {\n        if (mask & 1) {\n            axes.push(axis);\n        }\n        mask /= 2;\n        axis++;\n    }\n    return axes;\n}\n/** Computes the output shape given the strided slice params. */\nexport function computeOutShape(begin, end, strides) {\n    const size = [];\n    for (let axis = 0; axis < begin.length; axis++) {\n        size[axis] = Math.ceil((end[axis] - begin[axis]) / strides[axis]);\n    }\n    return size;\n}\nexport function startForAxis(beginMask, startIndices, strides, inputShape, axis) {\n    // Begin with the specified index\n    let start = startIndices[axis];\n    const stride = strides[axis] || 1;\n    // Check the axis bit from right of beginMask or the begin index is not set\n    // for the axis.\n    if (beginMask & 1 << axis || start == null) {\n        if (stride > 0) {\n            // Forward iteration - use the first element. These values will get\n            // clamped below (Note: We could have set them to 0 and axis_size-1, but\n            // use lowest() and max() to maintain symmetry with StopForAxis())\n            start = Number.MIN_SAFE_INTEGER;\n        }\n        else {\n            // Backward iteration - use the last element.\n            start = Number.MAX_SAFE_INTEGER;\n        }\n    }\n    // Handle negative indices\n    const axisSize = inputShape[axis];\n    if (start < 0) {\n        start += axisSize;\n    }\n    // Clamping\n    start = util.clamp(0, start, axisSize - 1);\n    return start;\n}\nexport function stopForAxis(endMask, stopIndices, strides, inputShape, axis) {\n    // Begin with the specified index\n    let stop = stopIndices[axis];\n    const stride = strides[axis] || 1;\n    // Check the axis bit from right of endMask or if the stop index is not set\n    // for this axis.\n    if (endMask & (1 << axis) || stop == null) {\n        if (stride > 0) {\n            // Forward iteration - use the last element. These values will get\n            // clamped below\n            stop = Number.MAX_SAFE_INTEGER;\n        }\n        else {\n            // Backward iteration - use the first element.\n            stop = Number.MIN_SAFE_INTEGER;\n        }\n    }\n    // Handle negative indices\n    const axisSize = inputShape[axis];\n    if (stop < 0) {\n        stop += axisSize;\n    }\n    // Clamping\n    // Because the end index points one past the last element, we need slightly\n    // different clamping ranges depending on the direction.\n    if (stride > 0) {\n        // Forward iteration\n        stop = util.clamp(0, stop, axisSize);\n    }\n    else {\n        // Backward iteration\n        stop = util.clamp(-1, stop, axisSize - 1);\n    }\n    return stop;\n}\n/**\n * Returns true if the slice occupies a continous set of elements in the\n * 'flat' space.\n */\nexport function isSliceContinous(shape, begin, size) {\n    // Index of the first axis that has size > 1.\n    let firstNonOneAxis = size.length;\n    for (let i = 0; i < size.length; i++) {\n        if (size[i] > 1) {\n            firstNonOneAxis = i;\n            break;\n        }\n    }\n    for (let i = firstNonOneAxis + 1; i < size.length; i++) {\n        if (begin[i] > 0 || size[i] !== shape[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nexport function computeFlatOffset(begin, strides) {\n    let flatOffset = begin.length > 0 ? begin[begin.length - 1] : 1;\n    for (let i = 0; i < begin.length - 1; i++) {\n        flatOffset += begin[i] * strides[i];\n    }\n    return flatOffset;\n}\n//# sourceMappingURL=slice_util.js.map"]},"metadata":{},"sourceType":"module"}